package com.vmenon.mpo.api.authn.security

import com.vmenon.mpo.api.authn.di.storageModule
import com.vmenon.mpo.api.authn.module
import com.vmenon.mpo.api.authn.testStorageModule
import com.vmenon.mpo.api.authn.testutils.BaseIntegrationTest
import com.vmenon.mpo.api.authn.testutils.WebAuthnTestHelpers
import com.vmenon.mpo.api.authn.utils.JacksonUtils
import com.vmenon.webauthn.testlib.WebAuthnTestAuthenticator
import com.yubico.webauthn.data.ByteArray
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.HttpStatusCode
import io.ktor.http.contentType
import io.ktor.server.testing.testApplication
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import org.koin.core.context.stopKoin
import kotlin.test.assertEquals
import kotlin.test.assertNotEquals
import kotlin.test.assertTrue
import kotlin.time.measureTime

/**
 * Vulnerability protection tests for WebAuthn implementation
 *
 * Tests to verify protection against known vulnerabilities:
 * - PoisonSeed attacks (cross-origin authentication abuse)
 * - Username enumeration (CVE-2024-39912)
 * - Replay attacks
 * - Credential tampering
 * - Origin confusion attacks
 *
 * These tests validate that the Yubico java-webauthn-server library
 * and KTor application are properly configured to prevent security issues.
 */
class VulnerabilityProtectionTest : BaseIntegrationTest() {
    private val objectMapper = JacksonUtils.objectMapper

    @BeforeEach
    fun setup() {
        stopKoin()
    }

    @AfterEach
    fun teardown() {
        stopKoin()
    }

    @Test
    @DisplayName("Should reject authentication attempts with invalid origins")
    fun `test protection against cross-origin poisonseed attacks`() =
        testApplication {
            application {
                module(storageModule)
            }

            val username = WebAuthnTestHelpers.generateTestUsername("poisonseed_test")
            val keyPair = WebAuthnTestHelpers.generateTestKeypair()

            // Register a user first
            val registrationResponse =
                WebAuthnTestHelpers.registerUser(
                    client,
                    username,
                    username,
                    keyPair,
                )
            if (registrationResponse.status == HttpStatusCode.OK) {
                // Now attempt authentication with malicious origin
                val maliciousOrigin = "https://evil-phishing-site.com"

                val authStartResponse =
                    client.post("/authenticate/start") {
                        contentType(ContentType.Application.Json)
                        header(HttpHeaders.Origin, maliciousOrigin)
                        setBody("""{"username": "$username"}""")
                    }

                if (authStartResponse.status == HttpStatusCode.OK) {
                    val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                    val authChallenge =
                        WebAuthnTestHelpers.extractChallenge(
                            authStartData,
                            "publicKeyCredentialRequestOptions",
                        )

                    // Create credential with malicious origin in clientDataJSON
                    val tamperedCredential =
                        WebAuthnTestHelpers.createTamperedCredentialWithOrigin(
                            authChallenge,
                            keyPair,
                            maliciousOrigin,
                        )

                    val authCompleteResponse =
                        client.post("/authenticate/complete") {
                            contentType(ContentType.Application.Json)
                            setBody(
                                objectMapper.writeValueAsString(
                                    mapOf(
                                        "requestId" to WebAuthnTestHelpers.extractRequestId(authStartData),
                                        "credential" to tamperedCredential,
                                    ),
                                ),
                            )
                        }

                    // The Yubico library should reject this due to origin mismatch
                    assertNotEquals(
                        HttpStatusCode.OK,
                        authCompleteResponse.status,
                        "Authentication with malicious origin should be rejected",
                    )

                    val responseBody = authCompleteResponse.bodyAsText()
                    assertTrue(
                        responseBody.contains("error") || authCompleteResponse.status.value >= 400,
                        "Response should indicate authentication failure: $responseBody",
                    )
                }
            }
        }

    @Test
    @DisplayName("Should provide consistent responses for existing vs non-existent users")
    fun `test protection against username enumeration via response differences`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            val existingUser = WebAuthnTestHelpers.generateTestUsername("existing")
            val nonExistentUser = WebAuthnTestHelpers.generateTestUsername("nonexistent")
            val keyPair = WebAuthnTestHelpers.generateTestKeypair()

            // Register the existing user
            WebAuthnTestHelpers.registerUser(client, existingUser, existingUser, keyPair)

            // Test authentication start for existing user
            val existingUserResponse = WebAuthnTestHelpers.startAuthentication(client, existingUser)

            // Test authentication start for non-existent user
            val nonExistentUserResponse =
                WebAuthnTestHelpers.startAuthentication(
                    client,
                    nonExistentUser,
                )

            // Analyze responses for enumeration vulnerabilities
            val existingUserData = objectMapper.readTree(existingUserResponse.bodyAsText())
            val nonExistentUserData = objectMapper.readTree(nonExistentUserResponse.bodyAsText())

            // Check if responses are too different (indicating enumeration vulnerability)
            val statusesMatch = existingUserResponse.status == nonExistentUserResponse.status
            val structuresMatch = existingUserData.has("requestId") == nonExistentUserData.has("requestId")

            // Print results for analysis
            println("Existing user status: ${existingUserResponse.status}")
            println("Non-existent user status: ${nonExistentUserResponse.status}")
            println("Existing user has requestId: ${existingUserData.has("requestId")}")
            println("Non-existent user has requestId: ${nonExistentUserData.has("requestId")}")

            // The Yubico library should handle this properly - this test documents current behavior
            assertTrue(
                statusesMatch && structuresMatch,
                "Responses should not reveal user existence differences that enable enumeration",
            )
        }

    @Test
    @DisplayName("Should have consistent response timing to prevent timing attacks")
    fun `test consistent timing prevents username enumeration`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            val existingUser = WebAuthnTestHelpers.generateTestUsername("timing_existing")
            val nonExistentUser = WebAuthnTestHelpers.generateTestUsername("timing_nonexistent")
            val keyPair = WebAuthnTestHelpers.generateTestKeypair()

            // Register the existing user
            WebAuthnTestHelpers.registerUser(client, existingUser, existingUser, keyPair)

            // Measure timing for existing user (multiple samples for accuracy)
            val existingUserTimes = mutableListOf<Long>()
            repeat(3) {
                val time =
                    measureTime {
                        WebAuthnTestHelpers.startAuthentication(client, existingUser)
                    }.inWholeMilliseconds
                existingUserTimes.add(time)
            }

            // Measure timing for non-existent user
            val nonExistentUserTimes = mutableListOf<Long>()
            repeat(3) {
                val time =
                    measureTime {
                        WebAuthnTestHelpers.startAuthentication(client, nonExistentUser)
                    }.inWholeMilliseconds
                nonExistentUserTimes.add(time)
            }

            val avgExistingTime = existingUserTimes.average()
            val avgNonExistentTime = nonExistentUserTimes.average()
            val timingDifference = kotlin.math.abs(avgExistingTime - avgNonExistentTime)

            println("Average existing user time: ${avgExistingTime}ms")
            println("Average non-existent user time: ${avgNonExistentTime}ms")
            println("Timing difference: ${timingDifference}ms")

            // Allow for reasonable variance in response times
            // Less than 200ms difference (generous for test environment)
            assertTrue(
                timingDifference < 200,
                "Timing difference of ${timingDifference}ms could enable username enumeration",
            )
        }

    @Test
    @DisplayName("Should prevent replay of authentication responses")
    fun `test protection against authentication replay attacks`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            val username = WebAuthnTestHelpers.generateTestUsername("replay_test")
            val keyPair = WebAuthnTestHelpers.generateTestKeypair()

            // Register user first
            val registrationResponse =
                WebAuthnTestHelpers.registerUser(
                    client,
                    username,
                    username,
                    keyPair,
                )
            if (registrationResponse.status == HttpStatusCode.OK) {
                // Perform first authentication
                val authStartResponse = WebAuthnTestHelpers.startAuthentication(client, username)
                if (authStartResponse.status == HttpStatusCode.OK) {
                    val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                    val authRequestId = WebAuthnTestHelpers.extractRequestId(authStartData)
                    val authChallenge =
                        WebAuthnTestHelpers.extractChallenge(
                            authStartData,
                            "publicKeyCredentialRequestOptions",
                        )
                    val credentialId = "test-credential-id"

                    // Create auth credential manually for replay testing
                    val authCredential =
                        WebAuthnTestAuthenticator.createAuthenticationCredential(
                            ByteArray.fromBase64Url(authChallenge).bytes,
                            ByteArray.fromBase64Url(credentialId).bytes,
                            keyPair,
                        )

                    val completeRequestBody =
                        objectMapper.writeValueAsString(
                            mapOf(
                                "requestId" to authRequestId,
                                "credential" to objectMapper.writeValueAsString(authCredential),
                            ),
                        )

                    // First authentication
                    client.post("/authenticate/complete") {
                        contentType(ContentType.Application.Json)
                        setBody(completeRequestBody)
                    }

                    // Attempt to replay the same request
                    val replayResponse =
                        client.post("/authenticate/complete") {
                            contentType(ContentType.Application.Json)
                            setBody(completeRequestBody)
                        }

                    // Replay should fail - request ID should be consumed
                    assertNotEquals(
                        HttpStatusCode.OK,
                        replayResponse.status,
                        "Replay attack should be rejected",
                    )

                    val replayResponseBody = replayResponse.bodyAsText()
                    assertTrue(
                        replayResponseBody.contains("Invalid or expired request ID") ||
                            replayResponseBody.contains("error"),
                        "Replay should be rejected with appropriate error: $replayResponseBody",
                    )
                }
            }
        }

    @Test
    @DisplayName("Should ensure challenge uniqueness across authentication attempts")
    fun `test challenge uniqueness prevents replay attacks`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            val username = WebAuthnTestHelpers.generateTestUsername("challenge_test")

            // Start multiple authentication sessions
            val auth1Response = WebAuthnTestHelpers.startAuthentication(client, username)
            val auth2Response = WebAuthnTestHelpers.startAuthentication(client, username)

            assertEquals(HttpStatusCode.OK, auth1Response.status, "First auth start should succeed")
            assertEquals(
                HttpStatusCode.OK,
                auth2Response.status,
                "Second auth start should succeed",
            )

            val auth1Data = objectMapper.readTree(auth1Response.bodyAsText())
            val auth2Data = objectMapper.readTree(auth2Response.bodyAsText())

            val challenge1 =
                WebAuthnTestHelpers.extractChallenge(
                    auth1Data,
                    "publicKeyCredentialRequestOptions",
                )
            val challenge2 =
                WebAuthnTestHelpers.extractChallenge(
                    auth2Data,
                    "publicKeyCredentialRequestOptions",
                )

            // Challenges should be unique
            assertNotEquals(
                challenge1,
                challenge2,
                "Each authentication session should have a unique challenge",
            )

            // Request IDs should also be unique
            val requestId1 = WebAuthnTestHelpers.extractRequestId(auth1Data)
            val requestId2 = WebAuthnTestHelpers.extractRequestId(auth2Data)

            assertNotEquals(
                requestId1,
                requestId2,
                "Each authentication session should have a unique request ID",
            )
        }

    @Test
    @DisplayName("Should detect and reject tampered credentials")
    fun `test protection against credential response tampering`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            val username = WebAuthnTestHelpers.generateTestUsername("tamper_test")
            val keyPair = WebAuthnTestHelpers.generateTestKeypair()

            // Register user first
            val registrationResponse =
                WebAuthnTestHelpers.registerUser(
                    client,
                    username,
                    username,
                    keyPair,
                )
            if (registrationResponse.status == HttpStatusCode.OK) {
                // Start authentication
                val authStartResponse = WebAuthnTestHelpers.startAuthentication(client, username)
                if (authStartResponse.status == HttpStatusCode.OK) {
                    val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                    val authRequestId = WebAuthnTestHelpers.extractRequestId(authStartData)
                    val authChallenge =
                        WebAuthnTestHelpers.extractChallenge(
                            authStartData,
                            "publicKeyCredentialRequestOptions",
                        )

                    // Create legitimate credential and tamper with it
                    val legitimateCredential =
                        WebAuthnTestAuthenticator.createAuthenticationCredential(
                            ByteArray.fromBase64Url(authChallenge).bytes,
                            ByteArray.fromBase64Url("test-credential-id").bytes,
                            keyPair,
                        )
                    val credentialJson = objectMapper.writeValueAsString(legitimateCredential)
                    val tamperedCredential =
                        WebAuthnTestHelpers.tamperCredentialSignature(
                            credentialJson,
                        )

                    // Attempt authentication with tampered credential
                    val tamperedAuthResponse =
                        client.post("/authenticate/complete") {
                            contentType(ContentType.Application.Json)
                            setBody(
                                objectMapper.writeValueAsString(
                                    mapOf(
                                        "requestId" to authRequestId,
                                        "credential" to tamperedCredential,
                                    ),
                                ),
                            )
                        }

                    // Tampered authentication should fail
                    assertNotEquals(
                        HttpStatusCode.OK,
                        tamperedAuthResponse.status,
                        "Authentication with tampered credential should be rejected",
                    )

                    val responseBody = tamperedAuthResponse.bodyAsText()
                    assertTrue(
                        responseBody.contains("error") || responseBody.contains("Authentication failed"),
                        "Response should indicate authentication failure: $responseBody",
                    )
                }
            }
        }

    @Test
    @DisplayName("Should verify basic security configurations work")
    fun `test basic webauthn security configurations`() =
        testApplication {
            application {
                module(testStorageModule)
            }

            // Test that basic WebAuthn flows work (indicating proper configuration)
            val username = WebAuthnTestHelpers.generateTestUsername("config_test")

            // Test registration works
            val registrationResult =
                WebAuthnTestHelpers.startRegistration(
                    client,
                    username,
                    username,
                )
            assertEquals(
                HttpStatusCode.OK,
                registrationResult.status,
                "Registration should work with proper configuration",
            )

            // Test authentication start works (even for non-existent user due to enumeration protection)
            val authResult = WebAuthnTestHelpers.startAuthentication(client, username)
            assertEquals(HttpStatusCode.OK, authResult.status, "Authentication start should work")

            println("✅ Basic WebAuthn security configurations are working properly")
        }
}
