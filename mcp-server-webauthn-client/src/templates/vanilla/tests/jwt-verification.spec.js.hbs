const { test, expect } = require('@playwright/test');

// Base URLs
const GATEWAY_URL = 'http://localhost:8000';
const SERVER_URL = '{{server_url}}';

/**
 * JWT Verification E2E Tests
 *
 * These tests verify the zero-trust JWT architecture:
 * - JWT token issuance on successful WebAuthn authentication
 * - Protected endpoint access with valid JWT
 * - Rejection of requests without JWT
 * - Rejection of requests with invalid JWT
 */

// Helper function to register and authenticate a user
async function registerAndAuthenticate(request, username) {
  const displayName = `Test User ${Date.now()}`;

  // 1. Start registration
  const regStartResponse = await request.post(`${SERVER_URL}/register/start`, {
    data: { username, displayName }
  });
  expect(regStartResponse.ok()).toBeTruthy();

  const regStartData = await regStartResponse.json();
  const { requestId, publicKeyCredentialCreationOptions } = regStartData;

  // 2. Complete registration (mock credential for testing)
  // In production, this would come from WebAuthn API
  const mockCredential = JSON.stringify({
    type: 'public-key',
    id: 'test-credential-id',
    rawId: Buffer.from('test-credential-id').toString('base64'),
    response: {
      clientDataJSON: Buffer.from(JSON.stringify({
        type: 'webauthn.create',
        challenge: publicKeyCredentialCreationOptions.publicKey.challenge,
        origin: 'http://localhost:8082'
      })).toString('base64'),
      attestationObject: 'mock-attestation'
    }
  });

  const regCompleteResponse = await request.post(`${SERVER_URL}/register/complete`, {
    data: { requestId, credential: mockCredential }
  });

  // May fail with mock data, but we continue to test JWT flow
  // In real E2E tests with actual WebAuthn, this would succeed

  // 3. Start authentication
  const authStartResponse = await request.post(`${SERVER_URL}/authenticate/start`, {
    data: { username }
  });
  expect(authStartResponse.ok()).toBeTruthy();

  const authStartData = await authStartResponse.json();
  const authRequestId = authStartData.requestId;

  // 4. Complete authentication (mock assertion)
  const mockAssertion = JSON.stringify({
    type: 'public-key',
    id: 'test-credential-id',
    rawId: Buffer.from('test-credential-id').toString('base64'),
    response: {
      clientDataJSON: Buffer.from(JSON.stringify({
        type: 'webauthn.get',
        challenge: authStartData.publicKeyCredentialRequestOptions.publicKey.challenge,
        origin: 'http://localhost:8082'
      })).toString('base64'),
      authenticatorData: 'mock-authenticator-data',
      signature: 'mock-signature'
    }
  });

  const authCompleteResponse = await request.post(`${SERVER_URL}/authenticate/complete`, {
    data: { requestId: authRequestId, credential: mockAssertion }
  });

  return authCompleteResponse;
}

test.describe('JWT Token Issuance', () => {
  test('should issue JWT on successful authentication', async ({ request }) => {
    const username = `jwt-test-${Date.now()}@example.com`;

    const authResponse = await registerAndAuthenticate(request, username);

    if (authResponse.ok()) {
      const data = await authResponse.json();

      // Verify JWT token structure
      expect(data).toHaveProperty('success');
      expect(data).toHaveProperty('access_token');
      expect(data).toHaveProperty('token_type');
      expect(data).toHaveProperty('expires_in');
      expect(data).toHaveProperty('username');

      expect(data.success).toBe(true);
      expect(data.token_type).toBe('Bearer');
      expect(data.expires_in).toBe(900); // 15 minutes
      expect(data.username).toBe(username);

      // Verify JWT format (3 parts separated by dots)
      const tokenParts = data.access_token.split('.');
      expect(tokenParts.length).toBe(3);

      // Verify JWT header (base64url decoded)
      const header = JSON.parse(Buffer.from(tokenParts[0], 'base64url').toString());
      expect(header.alg).toBe('RS256');
      expect(header.typ).toBe('JWT');

      // Verify JWT payload
      const payload = JSON.parse(Buffer.from(tokenParts[1], 'base64url').toString());
      expect(payload.iss).toBe('mpo-webauthn');
      expect(payload.sub).toBe(username);
      expect(payload.exp).toBeGreaterThan(Math.floor(Date.now() / 1000));
    }
  });
});

test.describe('Protected Endpoint Access', () => {
  test('should access protected endpoint with valid JWT', async ({ request }) => {
    const username = `jwt-protected-${Date.now()}@example.com`;

    const authResponse = await registerAndAuthenticate(request, username);

    if (authResponse.ok()) {
      const authData = await authResponse.json();
      const token = authData.access_token;

      // Access protected endpoint through Envoy Gateway
      const profileResponse = await request.get(`${GATEWAY_URL}/api/user/profile`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      expect(profileResponse.ok()).toBeTruthy();

      const profileData = await profileResponse.json();
      expect(profileData).toHaveProperty('username');
      expect(profileData.username).toBe(username);
      expect(profileData).toHaveProperty('message');
    }
  });

  test('should reject request without JWT', async ({ request }) => {
    // Try to access protected endpoint without Authorization header
    const response = await request.get(`${GATEWAY_URL}/api/user/profile`);

    // Should be rejected with 401 Unauthorized
    expect(response.status()).toBe(401);
  });

  test('should reject request with invalid JWT', async ({ request }) => {
    // Try with malformed token
    const invalidToken = 'invalid.jwt.token';

    const response = await request.get(`${GATEWAY_URL}/api/user/profile`, {
      headers: {
        'Authorization': `Bearer ${invalidToken}`
      }
    });

    // Should be rejected with 401 Unauthorized
    expect(response.status()).toBe(401);
  });

  test('should reject request with wrong token format', async ({ request }) => {
    // Try without "Bearer " prefix
    const token = 'some-random-token';

    const response = await request.get(`${GATEWAY_URL}/api/user/profile`, {
      headers: {
        'Authorization': token
      }
    });

    // Should be rejected with 401 Unauthorized
    expect(response.status()).toBe(401);
  });
});

test.describe('Public Key Endpoint', () => {
  test('should fetch public key from WebAuthn server', async ({ request }) => {
    const response = await request.get(`${SERVER_URL}/public-key`);

    expect(response.ok()).toBeTruthy();

    const publicKeyBase64 = await response.text();

    // Verify it's Base64-encoded
    expect(publicKeyBase64).toMatch(/^[A-Za-z0-9+/]+=*$/);

    // Verify it can be decoded
    const publicKeyBuffer = Buffer.from(publicKeyBase64, 'base64');
    expect(publicKeyBuffer.length).toBeGreaterThan(0);
  });
});

test.describe('Envoy Gateway Routing', () => {
  test('should route public endpoints without JWT', async ({ request }) => {
    // Health check should work without JWT
    const healthResponse = await request.get(`${GATEWAY_URL}/health`);
    expect(healthResponse.ok()).toBeTruthy();

    // Public key endpoint should work without JWT
    const publicKeyResponse = await request.get(`${GATEWAY_URL}/public-key`);
    expect(publicKeyResponse.ok()).toBeTruthy();
  });

  test('should protect /api/* endpoints', async ({ request }) => {
    // All /api/* endpoints should require JWT
    const endpoints = [
      '/api/user/profile',
      '/api/example/data'
    ];

    for (const endpoint of endpoints) {
      const response = await request.get(`${GATEWAY_URL}${endpoint}`);
      expect(response.status()).toBe(401);
    }
  });
});
