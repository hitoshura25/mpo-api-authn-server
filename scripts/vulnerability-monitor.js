#!/usr/bin/env node

/**
 * Vulnerability Monitor for WebAuthn Security
 * 
 * Monitors multiple sources for new WebAuthn/FIDO2 vulnerabilities:
 * - CVE databases
 * - Security advisories 
 * - Yubico security updates
 * - FIDO Alliance security notices
 */

import fs from 'fs';
import path from 'path';
import https from 'https';
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class VulnerabilityMonitor {
    constructor() {
        this.vulnerabilityFile = path.join(__dirname, '../vulnerability-tracking.json');
        this.testTemplateDir = path.join(__dirname, '../test-templates');
        this.knownVulnerabilities = this.loadKnownVulnerabilities();
    }

    loadKnownVulnerabilities() {
        try {
            if (fs.existsSync(this.vulnerabilityFile)) {
                return JSON.parse(fs.readFileSync(this.vulnerabilityFile, 'utf8'));
            }
        } catch (error) {
            console.error('Error loading vulnerability file:', error);
        }
        return {
            lastCheck: null,
            vulnerabilities: [
                {
                    id: 'CVE-2024-39912',
                    name: 'Username Enumeration in WebAuthn',
                    description: 'WebAuthn implementations may reveal user existence through response differences',
                    severity: 'medium',
                    testImplemented: true,
                    dateAdded: '2024-07-01'
                },
                {
                    id: 'POISONSEED-2024',
                    name: 'PoisonSeed Cross-Origin Attack',
                    description: 'Cross-origin authentication abuse in WebAuthn implementations',
                    severity: 'high',
                    testImplemented: true,
                    dateAdded: '2024-06-15'
                }
            ]
        };
    }

    async checkCVEDatabase(libraryData, libraryStatus) {
        try {
            console.log('ðŸ” Checking CVE database for WebAuthn vulnerabilities...');
            
            // Check for dry-run mode
            const isDryRun = process.argv.includes('--dry-run');
            if (isDryRun) {
                console.log('ðŸ§ª Running in dry-run mode - using mock data');
                return this.getMockCVEData();
            }
            
            const keywords = process.argv.includes('--test-filter') ? ['webauthn'] : ['webauthn', 'fido2', 'fido', 'passkey', 'passwordless', 'authenticator'];
            const rawCVEs = [];
            
            // Calculate date range - check last 90 days or since last check
            const lastCheck = this.knownVulnerabilities.lastCheck;
            const startDate = lastCheck ? new Date(lastCheck) : new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
            const endDate = new Date();
            
            // Format dates for NVD API (YYYY-MM-DDTHH:mm:ss:sss UTC)
            const pubStartDate = startDate.toISOString();
            const pubEndDate = endDate.toISOString();
            
            console.log(`Searching CVEs from ${pubStartDate.split('T')[0]} to ${pubEndDate.split('T')[0]}`);
            
            // Query NVD API for each keyword
            for (const keyword of keywords) {
                try {
                    const cves = await this.queryNVDAPI(keyword, pubStartDate, pubEndDate);
                    
                    for (const cve of cves) {
                        // Check if we already know about this CVE
                        const exists = this.knownVulnerabilities.vulnerabilities.some(v => v.id === cve.id);
                        
                        if (!exists && this.isWebAuthnRelated(cve)) {
                            console.log(`ðŸš¨ Found new CVE: ${cve.id} - ${cve.name}`);
                            rawCVEs.push(cve);
                        }
                    }
                    
                    // Rate limiting - NVD requests 6 second delay between requests
                    await new Promise(resolve => setTimeout(resolve, 6000));
                    
                } catch (error) {
                    console.warn(`âš ï¸  Failed to check keyword "${keyword}": ${error.message}`);
                }
            }
            
            // Correlate CVEs with library fixes
            const enrichedCVEs = this.correlateCVEsWithLibrary(rawCVEs, libraryData, libraryStatus);
            
            console.log(`âœ… CVE check complete. Found ${enrichedCVEs.length} new WebAuthn-related vulnerabilities.`);
            return enrichedCVEs;
            
        } catch (error) {
            console.error('âŒ Error checking CVE database:', error.message);
            return [];
        }
    }

    async queryNVDAPI(keyword, startDate, endDate, retryCount = 0) {
        const maxRetries = 3;
        const baseDelay = 2000; // 2 seconds
        
        return new Promise((resolve, reject) => {
            // NVD API 2.0 endpoint
            const baseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
            const params = new URLSearchParams({
                keywordSearch: keyword,
                pubStartDate: startDate,
                pubEndDate: endDate,
                resultsPerPage: '50'
            });
            
            const url = `${baseUrl}?${params}`;
            
            const request = https.get(url, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0'
                },
                timeout: 30000 // 30 second timeout
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        // Handle different response codes with appropriate retry logic
                        if (res.statusCode === 429) {
                            // Rate limited - retry with exponential backoff
                            if (retryCount < maxRetries) {
                                const delay = baseDelay * Math.pow(2, retryCount);
                                console.warn(`âš ï¸  Rate limited, retrying in ${delay}ms (attempt ${retryCount + 1}/${maxRetries + 1})`);
                                setTimeout(() => {
                                    this.queryNVDAPI(keyword, startDate, endDate, retryCount + 1)
                                        .then(resolve)
                                        .catch(reject);
                                }, delay);
                                return;
                            } else {
                                reject(new Error(`NVD API rate limit exceeded after ${maxRetries} retries`));
                                return;
                            }
                        }
                        
                        if (res.statusCode === 503) {
                            // Service unavailable - retry with backoff
                            if (retryCount < maxRetries) {
                                const delay = baseDelay * Math.pow(2, retryCount);
                                console.warn(`âš ï¸  Service unavailable, retrying in ${delay}ms (attempt ${retryCount + 1}/${maxRetries + 1})`);
                                setTimeout(() => {
                                    this.queryNVDAPI(keyword, startDate, endDate, retryCount + 1)
                                        .then(resolve)
                                        .catch(reject);
                                }, delay);
                                return;
                            } else {
                                reject(new Error(`NVD API service unavailable after ${maxRetries} retries`));
                                return;
                            }
                        }
                        
                        if (res.statusCode !== 200) {
                            reject(new Error(`NVD API returned status ${res.statusCode}: ${data.substring(0, 200)}`));
                            return;
                        }
                        
                        // Handle empty or malformed responses
                        if (!data || data.trim().length === 0) {
                            console.warn(`âš ï¸  Empty response from NVD API for keyword "${keyword}"`);
                            resolve([]);
                            return;
                        }
                        
                        const response = JSON.parse(data);
                        
                        // Validate response structure
                        if (!response || typeof response !== 'object') {
                            console.warn(`âš ï¸  Invalid response structure from NVD API for keyword "${keyword}"`);
                            resolve([]);
                            return;
                        }
                        
                        const cves = this.parseNVDResponse(response);
                        resolve(cves);
                        
                    } catch (error) {
                        if (error instanceof SyntaxError) {
                            console.warn(`âš ï¸  Invalid JSON response from NVD API for keyword "${keyword}": ${error.message}`);
                            resolve([]);
                        } else {
                            reject(new Error(`Failed to parse NVD response: ${error.message}`));
                        }
                    }
                });
                
            });
            
            request.on('timeout', () => {
                request.destroy();
                if (retryCount < maxRetries) {
                    console.warn(`âš ï¸  Request timeout, retrying (attempt ${retryCount + 1}/${maxRetries + 1})`);
                    setTimeout(() => {
                        this.queryNVDAPI(keyword, startDate, endDate, retryCount + 1)
                            .then(resolve)
                            .catch(reject);
                    }, baseDelay);
                } else {
                    reject(new Error(`NVD API request timeout after ${maxRetries} retries`));
                }
            });
            
            request.on('error', (error) => {
                if (retryCount < maxRetries && (error.code === 'ECONNRESET' || error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED')) {
                    console.warn(`âš ï¸  Network error, retrying (attempt ${retryCount + 1}/${maxRetries + 1}): ${error.message}`);
                    setTimeout(() => {
                        this.queryNVDAPI(keyword, startDate, endDate, retryCount + 1)
                            .then(resolve)
                            .catch(reject);
                    }, baseDelay);
                } else {
                    reject(new Error(`NVD API request failed: ${error.message}`));
                }
            });
        });
    }

    parseNVDResponse(response) {
        const cves = [];
        
        if (!response.vulnerabilities) {
            return cves;
        }
        
        for (const vuln of response.vulnerabilities) {
            const cve = vuln.cve;
            
            try {
                // Extract basic information
                const id = cve.id;
                const description = cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available';
                
                // Extract CVSS score and severity
                let cvssScore = 0;
                let severity = 'unknown';
                
                if (cve.metrics?.cvssMetricV31?.[0]) {
                    const metrics = cve.metrics.cvssMetricV31[0];
                    cvssScore = metrics.cvssData.baseScore;
                    severity = metrics.cvssData.baseSeverity?.toLowerCase() || 'unknown';
                } else if (cve.metrics?.cvssMetricV30?.[0]) {
                    const metrics = cve.metrics.cvssMetricV30[0];
                    cvssScore = metrics.cvssData.baseScore;
                    severity = metrics.cvssData.baseSeverity?.toLowerCase() || 'unknown';
                } else if (cve.metrics?.cvssMetricV2?.[0]) {
                    const metrics = cve.metrics.cvssMetricV2[0];
                    cvssScore = metrics.cvssData.baseScore;
                    // Map CVSS v2 score to severity
                    if (cvssScore >= 7.0) severity = 'high';
                    else if (cvssScore >= 4.0) severity = 'medium';
                    else severity = 'low';
                }
                
                // Extract publication date
                const publishedDate = cve.published;
                
                cves.push({
                    id: id,
                    name: `${id} - WebAuthn Vulnerability`,
                    description: description.substring(0, 500) + (description.length > 500 ? '...' : ''),
                    severity: severity,
                    cvssScore: cvssScore,
                    testImplemented: false,
                    dateAdded: new Date().toISOString().split('T')[0],
                    source: 'NVD CVE Database',
                    publishedDate: publishedDate,
                    affectedComponents: this.extractAffectedComponents(description),
                    mitigation: 'Review CVE details and implement appropriate fixes'
                });
                
            } catch (error) {
                console.warn(`âš ï¸  Failed to parse CVE ${cve.id}: ${error.message}`);
            }
        }
        
        return cves;
    }

    isWebAuthnRelated(cve) {
        const text = (cve.description + ' ' + cve.name).toLowerCase();
        
        // High-confidence WebAuthn keywords (direct matches)
        const directWebAuthnKeywords = [
            'webauthn', 'web authentication', 'fido2', 'fido', 'passkey', 'passwordless',
            'public key credential', 'assertion', 'attestation', 'relying party',
            'java-webauthn-server', 'yubico', 'yubikey'
        ];
        
        // Context-dependent keywords (need additional validation)
        const contextualKeywords = [
            'authenticator', 'credential', 'biometric', 'security key'
        ];
        
        // Exclude false positive patterns
        const excludePatterns = [
            'oauth', 'saml', 'ldap', 'active directory', 'certificate authority',
            'ssl', 'tls', 'ssh', 'vpn', 'database credential', 'api key',
            'password hash', 'encryption key', 'private key', 'digital certificate'
        ];
        
        // Check for exclusion patterns first
        if (excludePatterns.some(pattern => text.includes(pattern))) {
            // Only exclude if it doesn't also contain direct WebAuthn keywords
            if (!directWebAuthnKeywords.some(keyword => text.includes(keyword))) {
                return false;
            }
        }
        
        // Direct WebAuthn match
        if (directWebAuthnKeywords.some(keyword => text.includes(keyword))) {
            return true;
        }
        
        // Contextual match with additional validation
        if (contextualKeywords.some(keyword => text.includes(keyword))) {
            // Look for supporting context that indicates WebAuthn
            const supportingContext = [
                'browser', 'client', 'origin', 'challenge', 'signature',
                'registration', 'authentication', 'user verification',
                'cross-origin', 'same-origin', 'javascript', 'web application'
            ];
            
            if (supportingContext.some(context => text.includes(context))) {
                return true;
            }
        }
        
        return false;
    }

    extractAffectedComponents(description) {
        const components = [];
        const text = description.toLowerCase();
        
        if (text.includes('authentication') || text.includes('login')) components.push('authentication flows');
        if (text.includes('registration') || text.includes('enrollment')) components.push('registration flows');
        if (text.includes('origin') || text.includes('cross-origin')) components.push('origin validation');
        if (text.includes('credential') || text.includes('key')) components.push('credential management');
        if (text.includes('session') || text.includes('token')) components.push('session management');
        if (text.includes('user') || text.includes('username')) components.push('user enumeration');
        if (text.includes('replay') || text.includes('reuse')) components.push('replay protection');
        if (text.includes('timing') || text.includes('side-channel')) components.push('timing attacks');
        
        return components.length > 0 ? components : ['general webauthn'];
    }

    getMockCVEData() {
        // Mock data for testing - simulates finding new CVEs
        return [
            {
                id: 'CVE-2024-TEST-1',
                name: 'CVE-2024-TEST-1 - WebAuthn Mock Vulnerability',
                description: 'Mock vulnerability for testing the monitoring system. This simulates a real WebAuthn vulnerability.',
                severity: 'medium',
                cvssScore: 5.5,
                testImplemented: false,
                dateAdded: new Date().toISOString().split('T')[0],
                source: 'Mock Data',
                publishedDate: new Date().toISOString(),
                affectedComponents: ['authentication flows', 'testing'],
                mitigation: 'This is a mock vulnerability for testing purposes only',
                recommendedAction: 'manual_implementation',
                isLibraryMitigated: false
            }
        ];
    }

    async checkYubicoAdvisories() {
        console.log('ðŸ” Checking Yubico java-webauthn-server security status...');
        
        try {
            const [libraryAdvisories, dependencyStatus] = await Promise.all([
                this.fetchJavaWebAuthnServerAdvisories(),
                this.checkJavaWebAuthnServerDependency()
            ]);
            
            const actionableAdvisories = this.createActionableAdvisories(libraryAdvisories, dependencyStatus);
            
            console.log(`âœ… Yubico library check complete. Found ${actionableAdvisories.length} actionable security recommendations.`);
            return actionableAdvisories;
            
        } catch (error) {
            console.warn(`âš ï¸  Failed to check Yubico library security: ${error.message}`);
            return [];
        }
    }

    async fetchJavaWebAuthnServerAdvisories() {
        const repository = 'Yubico/java-webauthn-server';
        
        try {
            const [securityAdvisories, releases, newsContent] = await Promise.all([
                this.fetchGitHubSecurityAdvisories(repository),
                this.fetchGitHubReleases(repository),
                this.fetchGitHubFileContent(repository, 'NEWS')
            ]);
            
            return {
                securityAdvisories,
                releases,
                newsContent
            };
            
        } catch (error) {
            console.warn(`âš ï¸  Failed to fetch java-webauthn-server advisories: ${error.message}`);
            return { securityAdvisories: [], releases: [], newsContent: '' };
        }
    }

    async fetchGitHubReleases(repository) {
        const apiUrl = `https://api.github.com/repos/${repository}/releases`;
        
        return new Promise((resolve, reject) => {
            https.get(apiUrl, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/vnd.github+json'
                },
                timeout: 30000
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode !== 200) {
                            reject(new Error(`GitHub API returned status ${res.statusCode}`));
                            return;
                        }
                        
                        const releases = JSON.parse(data);
                        resolve(releases.slice(0, 10)); // Get last 10 releases
                        
                    } catch (error) {
                        reject(new Error(`Failed to parse releases response: ${error.message}`));
                    }
                });
                
            }).on('error', (error) => {
                reject(new Error(`GitHub API request failed: ${error.message}`));
            });
        });
    }

    async fetchGitHubFileContent(repository, filePath) {
        const apiUrl = `https://api.github.com/repos/${repository}/contents/${filePath}`;
        
        return new Promise((resolve, reject) => {
            https.get(apiUrl, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/vnd.github+json'
                },
                timeout: 30000
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode === 404) {
                            resolve('');
                            return;
                        }
                        
                        if (res.statusCode !== 200) {
                            reject(new Error(`GitHub API returned status ${res.statusCode}`));
                            return;
                        }
                        
                        const fileInfo = JSON.parse(data);
                        const content = Buffer.from(fileInfo.content, 'base64').toString('utf8');
                        resolve(content);
                        
                    } catch (error) {
                        reject(new Error(`Failed to parse file content: ${error.message}`));
                    }
                });
                
            }).on('error', (error) => {
                reject(new Error(`GitHub API request failed: ${error.message}`));
            });
        });
    }

    async fetchGitHubSecurityAdvisories(repository) {
        const apiUrl = `https://api.github.com/repos/${repository}/security-advisories`;
        
        return new Promise((resolve, reject) => {
            https.get(apiUrl, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/vnd.github+json'
                },
                timeout: 30000
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode === 404) {
                            resolve([]);
                            return;
                        }
                        
                        if (res.statusCode !== 200) {
                            reject(new Error(`GitHub API returned status ${res.statusCode} for ${repository}`));
                            return;
                        }
                        
                        const advisories = JSON.parse(data);
                        resolve(advisories);
                        
                    } catch (error) {
                        reject(new Error(`Failed to parse GitHub advisories response: ${error.message}`));
                    }
                });
                
            }).on('error', (error) => {
                reject(new Error(`GitHub API request failed: ${error.message}`));
            });
        });
    }

    async checkJavaWebAuthnServerDependency() {
        try {
            const buildGradleContent = await this.readProjectBuildFile();
            const currentVersion = this.extractCurrentLibraryVersion(buildGradleContent);
            
            return {
                currentVersion,
                buildFileContent: buildGradleContent
            };
            
        } catch (error) {
            console.warn(`âš ï¸  Failed to check dependency status: ${error.message}`);
            return { currentVersion: null, buildFileContent: '' };
        }
    }

    async readProjectBuildFile() {
        const buildFilePath = path.join(__dirname, '../build.gradle.kts');
        
        try {
            return fs.readFileSync(buildFilePath, 'utf8');
        } catch (error) {
            throw new Error(`Failed to read build file: ${error.message}`);
        }
    }

    extractCurrentLibraryVersion(buildContent) {
        const versionPatterns = [
            /implementation\s*\(\s*["']com\.yubico:webauthn-server-core:([^"']+)["']\s*\)/,
            /webauthn-server-core['"]\s*version\s*["']([^"']+)["']/,
            /yubico.*webauthn.*["']([0-9]+\.[0-9]+\.[0-9]+[^"']*)["']/i
        ];
        
        for (const pattern of versionPatterns) {
            const match = buildContent.match(pattern);
            if (match) {
                return match[1];
            }
        }
        
        return null;
    }

    createActionableAdvisories(libraryData, dependencyStatus) {
        const actionableAdvisories = [];
        
        if (!libraryData.releases || libraryData.releases.length === 0) {
            return actionableAdvisories;
        }
        
        const latestRelease = libraryData.releases[0];
        const latestVersion = latestRelease.tag_name;
        const currentVersion = dependencyStatus.currentVersion;
        
        if (currentVersion && this.isVersionOutdated(currentVersion, latestVersion)) {
            const securityReleases = this.findSecurityReleases(libraryData.releases, libraryData.newsContent);
            
            if (securityReleases.length > 0) {
                const advisory = {
                    id: `JAVA-WEBAUTHN-DEPENDENCY-UPDATE-${Date.now()}`,
                    name: 'java-webauthn-server Security Update Available',
                    description: this.buildDependencyUpdateDescription(currentVersion, latestVersion, securityReleases),
                    severity: this.calculateUpdateSeverity(securityReleases),
                    cvssScore: this.calculateUpdateCvssScore(securityReleases),
                    testImplemented: false,
                    dateAdded: new Date().toISOString().split('T')[0],
                    source: 'Dependency Analysis',
                    publishedDate: latestRelease.published_at,
                    affectedComponents: ['java-webauthn-server', 'webauthn authentication'],
                    mitigation: this.buildDependencyUpdateMitigation(currentVersion, latestVersion),
                    updateInfo: {
                        currentVersion,
                        latestVersion,
                        securityReleases: securityReleases.map(r => r.tag_name),
                        updateCommand: `implementation("com.yubico:webauthn-server-core:${latestVersion}")`
                    }
                };
                
                actionableAdvisories.push(advisory);
            }
        }
        
        for (const securityAdvisory of libraryData.securityAdvisories) {
            if (!this.isKnownVulnerability(securityAdvisory.ghsa_id)) {
                const processedAdvisory = this.processLibrarySecurityAdvisory(securityAdvisory, dependencyStatus);
                actionableAdvisories.push(processedAdvisory);
            }
        }
        
        return actionableAdvisories;
    }

    isVersionOutdated(currentVersion, latestVersion) {
        const current = this.parseVersion(currentVersion);
        const latest = this.parseVersion(latestVersion);
        
        return current.major < latest.major || 
               (current.major === latest.major && current.minor < latest.minor) ||
               (current.major === latest.major && current.minor === latest.minor && current.patch < latest.patch);
    }

    parseVersion(versionString) {
        const cleanVersion = versionString.replace(/^v/, '');
        const parts = cleanVersion.split('.');
        
        return {
            major: parseInt(parts[0] || '0', 10),
            minor: parseInt(parts[1] || '0', 10),
            patch: parseInt(parts[2] || '0', 10)
        };
    }

    findSecurityReleases(releases, newsContent) {
        const securityKeywords = ['security', 'vulnerability', 'cve', 'fix', 'patch', 'advisory'];
        const securityReleases = [];
        
        for (const release of releases) {
            const releaseText = (release.body || '').toLowerCase();
            const hasSecurityContent = securityKeywords.some(keyword => releaseText.includes(keyword));
            
            if (hasSecurityContent) {
                securityReleases.push(release);
            }
        }
        
        return securityReleases;
    }

    buildDependencyUpdateDescription(currentVersion, latestVersion, securityReleases) {
        let description = `Current java-webauthn-server version ${currentVersion} is outdated. `;
        description += `Latest version ${latestVersion} includes security improvements. `;
        
        if (securityReleases.length > 0) {
            const securityVersions = securityReleases.map(r => r.tag_name).join(', ');
            description += `Security fixes available in versions: ${securityVersions}.`;
        }
        
        return description;
    }

    calculateUpdateSeverity(securityReleases) {
        if (securityReleases.length === 0) return 'low';
        
        const hasMultipleSecurityReleases = securityReleases.length >= 2;
        const hasRecentSecurityRelease = securityReleases.some(r => {
            const releaseDate = new Date(r.published_at);
            const sixMonthsAgo = new Date(Date.now() - 180 * 24 * 60 * 60 * 1000);
            return releaseDate > sixMonthsAgo;
        });
        
        if (hasMultipleSecurityReleases || hasRecentSecurityRelease) {
            return 'high';
        }
        
        return 'medium';
    }

    calculateUpdateCvssScore(securityReleases) {
        if (securityReleases.length === 0) return 3.0;
        if (securityReleases.length >= 2) return 7.5;
        return 5.5;
    }

    buildDependencyUpdateMitigation(currentVersion, latestVersion) {
        return `Update java-webauthn-server dependency from ${currentVersion} to ${latestVersion}. ` +
               `Modify build.gradle.kts: implementation("com.yubico:webauthn-server-core:${latestVersion}"). ` +
               `Run './gradlew build' and './gradlew test' to verify compatibility.`;
    }

    processLibrarySecurityAdvisory(advisory, dependencyStatus) {
        return {
            id: advisory.ghsa_id,
            name: `java-webauthn-server: ${advisory.summary}`,
            description: advisory.description || advisory.summary,
            severity: this.mapGitHubSeverity(advisory.severity),
            cvssScore: advisory.cvss?.score || this.getDefaultCvssScore(advisory.severity),
            testImplemented: false,
            dateAdded: new Date().toISOString().split('T')[0],
            source: 'GitHub Security Advisory',
            publishedDate: advisory.published_at,
            affectedComponents: ['java-webauthn-server', 'webauthn authentication'],
            mitigation: this.generateLibraryAdvisoryMitigation(advisory, dependencyStatus),
            cveId: advisory.cve_id,
            ghsaId: advisory.ghsa_id
        };
    }

    generateLibraryAdvisoryMitigation(advisory, dependencyStatus) {
        let mitigation = 'Review the security advisory for java-webauthn-server. ';
        
        if (dependencyStatus.currentVersion) {
            mitigation += `Current version: ${dependencyStatus.currentVersion}. `;
        }
        
        if (advisory.cve_id) {
            mitigation += `CVE ID: ${advisory.cve_id}. `;
        }
        
        mitigation += 'Update to the latest version if a fix is available.';
        
        return mitigation;
    }

    correlateCVEsWithLibrary(cves, libraryData, libraryStatus) {
        const enrichedCVEs = [];
        
        for (const cve of cves) {
            const libraryMitigation = this.checkLibraryMitigationForCVE(cve, libraryData, libraryStatus);
            
            const enrichedCVE = {
                ...cve,
                libraryMitigation: libraryMitigation.mitigation,
                isLibraryMitigated: libraryMitigation.isMitigated,
                recommendedAction: libraryMitigation.recommendedAction
            };
            
            enrichedCVEs.push(enrichedCVE);
        }
        
        return enrichedCVEs;
    }

    correlateFIDONoticesWithLibrary(notices, libraryData, libraryStatus) {
        const enrichedNotices = [];
        
        for (const notice of notices) {
            const libraryMitigation = this.checkLibraryMitigationForFIDONotice(notice, libraryData, libraryStatus);
            
            const enrichedNotice = {
                ...notice,
                libraryMitigation: libraryMitigation.mitigation,
                isLibraryMitigated: libraryMitigation.isMitigated,
                recommendedAction: libraryMitigation.recommendedAction
            };
            
            enrichedNotices.push(enrichedNotice);
        }
        
        return enrichedNotices;
    }

    checkLibraryMitigationForCVE(cve, libraryData, libraryStatus) {
        const cveKeywords = [cve.id.toLowerCase(), 'webauthn', 'fido2', 'authentication'];
        const currentVersion = libraryStatus.currentVersion;
        
        if (!libraryData.releases || !currentVersion) {
            return {
                isMitigated: false,
                mitigation: 'Unable to determine library mitigation status',
                recommendedAction: 'manual_review'
            };
        }
        
        // Check if CVE ID appears in any release notes or NEWS file
        const relevantReleases = this.findReleasesAddressingIssue(cveKeywords, libraryData.releases, libraryData.newsContent);
        
        if (relevantReleases.length > 0) {
            const latestFixVersion = relevantReleases[0].tag_name;
            const isCurrentVersionVulnerable = this.isVersionOutdated(currentVersion, latestFixVersion);
            
            if (isCurrentVersionVulnerable) {
                return {
                    isMitigated: true,
                    mitigation: `CVE ${cve.id} addressed in java-webauthn-server ${latestFixVersion}. Current version ${currentVersion} is vulnerable.`,
                    recommendedAction: 'update_dependency',
                    fixVersion: latestFixVersion
                };
            } else {
                return {
                    isMitigated: true,
                    mitigation: `CVE ${cve.id} already addressed in current java-webauthn-server version ${currentVersion}`,
                    recommendedAction: 'no_action_needed'
                };
            }
        }
        
        // Check if it's a general WebAuthn vulnerability that might be mitigated by latest version
        if (this.isGeneralWebAuthnVulnerability(cve)) {
            const latestVersion = libraryData.releases[0]?.tag_name;
            const isOutdated = latestVersion && this.isVersionOutdated(currentVersion, latestVersion);
            
            if (isOutdated) {
                return {
                    isMitigated: false,
                    mitigation: `General WebAuthn vulnerability. Consider updating to latest version ${latestVersion} for general security improvements.`,
                    recommendedAction: 'consider_update',
                    suggestedVersion: latestVersion
                };
            }
        }
        
        return {
            isMitigated: false,
            mitigation: 'Requires manual security review and potentially custom implementation',
            recommendedAction: 'manual_implementation'
        };
    }

    checkLibraryMitigationForFIDONotice(notice, libraryData, libraryStatus) {
        // FIDO notices are typically about specific authenticators, not the library itself
        // But we can check if the library has updates that might address general concerns
        
        const currentVersion = libraryStatus.currentVersion;
        
        if (!libraryData.releases || !currentVersion) {
            return {
                isMitigated: false,
                mitigation: 'Unable to determine library mitigation status for FIDO notice',
                recommendedAction: 'manual_review'
            };
        }
        
        // Check if this is about authenticator metadata service handling
        if (notice.description.toLowerCase().includes('metadata') || 
            notice.description.toLowerCase().includes('attestation')) {
            
            const latestVersion = libraryData.releases[0]?.tag_name;
            const isOutdated = latestVersion && this.isVersionOutdated(currentVersion, latestVersion);
            
            if (isOutdated) {
                return {
                    isMitigated: true,
                    mitigation: `FIDO MDS notice may be addressed by updating to latest java-webauthn-server ${latestVersion} which includes updated authenticator handling`,
                    recommendedAction: 'update_dependency',
                    suggestedVersion: latestVersion
                };
            }
        }
        
        return {
            isMitigated: false,
            mitigation: 'FIDO Alliance notice requires manual review - typically relates to specific authenticator models rather than server library',
            recommendedAction: 'manual_review'
        };
    }

    findReleasesAddressingIssue(keywords, releases, newsContent) {
        const relevantReleases = [];
        
        // Check NEWS file for CVE mentions
        if (newsContent) {
            const newsLower = newsContent.toLowerCase();
            const hasRelevantContent = keywords.some(keyword => newsLower.includes(keyword));
            
            if (hasRelevantContent) {
                // Find which versions might have addressed this
                for (const release of releases) {
                    const releaseText = (release.body || '').toLowerCase();
                    const hasKeyword = keywords.some(keyword => releaseText.includes(keyword));
                    
                    if (hasKeyword) {
                        relevantReleases.push(release);
                    }
                }
            }
        }
        
        // Also check release notes directly
        for (const release of releases) {
            const releaseText = (release.body || '').toLowerCase();
            const hasKeyword = keywords.some(keyword => releaseText.includes(keyword));
            
            if (hasKeyword && !relevantReleases.some(r => r.tag_name === release.tag_name)) {
                relevantReleases.push(release);
            }
        }
        
        return relevantReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
    }

    isGeneralWebAuthnVulnerability(cve) {
        const description = cve.description.toLowerCase();
        const generalPatterns = [
            'webauthn',
            'web authentication',
            'fido2',
            'public key credential',
            'authenticator',
            'relying party'
        ];
        
        return generalPatterns.some(pattern => description.includes(pattern));
    }

    categorizeVulnerabilities(vulnerabilities, libraryData, libraryStatus) {
        const actionableVulns = [];
        const libraryMitigatedVulns = [];
        
        for (const vuln of vulnerabilities) {
            if (vuln.isLibraryMitigated && 
                (vuln.recommendedAction === 'update_dependency' || vuln.recommendedAction === 'consider_update')) {
                libraryMitigatedVulns.push(vuln);
            } else if (vuln.recommendedAction === 'manual_implementation') {
                actionableVulns.push(vuln);
            }
            // Skip 'no_action_needed' and 'manual_review' items unless they're critical
        }
        
        return { actionableVulns, libraryMitigatedVulns };
    }


    mapGitHubSeverity(severity) {
        const severityMap = {
            'critical': 'critical',
            'high': 'high',
            'moderate': 'medium',
            'medium': 'medium',
            'low': 'low'
        };
        
        return severityMap[severity?.toLowerCase()] || 'medium';
    }

    getDefaultCvssScore(severity) {
        const scoreMap = {
            'critical': 9.0,
            'high': 7.5,
            'moderate': 5.5,
            'medium': 5.5,
            'low': 3.0
        };
        
        return scoreMap[severity?.toLowerCase()] || 5.5;
    }


    async checkFIDOAllianceNotices(libraryData, libraryStatus) {
        console.log('ðŸ” Checking FIDO Alliance Metadata Service for security notices...');
        
        try {
            const fidoMdsData = await this.fetchFIDOMetadataService();
            const rawSecurityNotices = this.parseFIDOSecurityNotices(fidoMdsData);
            
            // Correlate FIDO notices with library fixes
            const enrichedNotices = this.correlateFIDONoticesWithLibrary(rawSecurityNotices, libraryData, libraryStatus);
            
            console.log(`âœ… FIDO MDS check complete. Found ${enrichedNotices.length} security-related entries.`);
            return enrichedNotices;
            
        } catch (error) {
            console.warn(`âš ï¸  Failed to check FIDO Alliance MDS: ${error.message}`);
            return [];
        }
    }

    async fetchFIDOMetadataService() {
        const mdsUrl = 'https://mds.fidoalliance.org/';
        
        return new Promise((resolve, reject) => {
            const request = https.get(mdsUrl, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/jwt, application/json'
                },
                timeout: 30000
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode === 301 || res.statusCode === 302) {
                            const redirectUrl = res.headers.location;
                            if (redirectUrl) {
                                console.log(`Following redirect to: ${redirectUrl}`);
                                this.fetchFromRedirectUrl(redirectUrl)
                                    .then(resolve)
                                    .catch(reject);
                                return;
                            }
                        }
                        
                        if (res.statusCode !== 200) {
                            reject(new Error(`FIDO MDS returned status ${res.statusCode}`));
                            return;
                        }
                        
                        const mdsBlob = this.decodeFIDOMetadataJWT(data);
                        resolve(mdsBlob);
                        
                    } catch (error) {
                        reject(new Error(`Failed to process FIDO MDS response: ${error.message}`));
                    }
                });
                
            });
            
            request.on('error', (error) => {
                reject(new Error(`FIDO MDS request failed: ${error.message}`));
            });
            
            request.on('timeout', () => {
                request.destroy();
                reject(new Error('FIDO MDS request timeout'));
            });
        });
    }

    async fetchFromRedirectUrl(redirectUrl) {
        return new Promise((resolve, reject) => {
            https.get(redirectUrl, {
                headers: {
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/jwt, application/json'
                },
                timeout: 30000
            }, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode !== 200) {
                            reject(new Error(`FIDO MDS redirect returned status ${res.statusCode}`));
                            return;
                        }
                        
                        const mdsBlob = this.decodeFIDOMetadataJWT(data);
                        resolve(mdsBlob);
                        
                    } catch (error) {
                        reject(new Error(`Failed to process FIDO MDS redirect response: ${error.message}`));
                    }
                });
                
            }).on('error', (error) => {
                reject(new Error(`FIDO MDS redirect request failed: ${error.message}`));
            });
        });
    }

    decodeFIDOMetadataJWT(jwtData) {
        try {
            const parts = jwtData.trim().split('.');
            
            if (parts.length !== 3) {
                throw new Error('Invalid JWT format - expected 3 parts');
            }
            
            const payloadBase64 = parts[1];
            const paddedPayload = payloadBase64 + '='.repeat((4 - payloadBase64.length % 4) % 4);
            const payloadJson = Buffer.from(paddedPayload, 'base64').toString('utf8');
            
            const payload = JSON.parse(payloadJson);
            return payload;
            
        } catch (error) {
            if (jwtData.trim().startsWith('{')) {
                return JSON.parse(jwtData);
            }
            throw new Error(`Failed to decode FIDO MDS JWT: ${error.message}`);
        }
    }

    parseFIDOSecurityNotices(mdsBlob) {
        const securityNotices = [];
        
        if (!mdsBlob?.entries) {
            return securityNotices;
        }
        
        const lastCheckDate = this.knownVulnerabilities.lastCheck 
            ? new Date(this.knownVulnerabilities.lastCheck) 
            : new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
        
        for (const entry of mdsBlob.entries) {
            try {
                const metadataStatement = entry.metadataStatement;
                if (!metadataStatement) continue;
                
                const statusReports = entry.statusReports || [];
                const authenticatorDescription = metadataStatement.description || 'Unknown FIDO Authenticator';
                
                for (const statusReport of statusReports) {
                    if (this.isSecurityRelevantStatus(statusReport)) {
                        const effectiveDate = new Date(statusReport.effectiveDate);
                        
                        if (effectiveDate > lastCheckDate) {
                            const vulnerabilityId = this.generateFIDOVulnerabilityId(entry, statusReport);
                            
                            if (!this.isKnownVulnerability(vulnerabilityId)) {
                                const securityNotice = this.createSecurityNoticeFromStatusReport(
                                    vulnerabilityId,
                                    authenticatorDescription,
                                    statusReport,
                                    metadataStatement
                                );
                                
                                securityNotices.push(securityNotice);
                                console.log(`ðŸš¨ Found FIDO security notice: ${vulnerabilityId} - ${authenticatorDescription}`);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.warn(`âš ï¸  Failed to parse FIDO MDS entry: ${error.message}`);
            }
        }
        
        return securityNotices;
    }

    isSecurityRelevantStatus(statusReport) {
        const securityStatuses = [
            'REVOKED',
            'USER_VERIFICATION_BYPASS',
            'ATTESTATION_KEY_COMPROMISE', 
            'USER_KEY_REMOTE_COMPROMISE',
            'USER_KEY_PHYSICAL_COMPROMISE',
            'UPDATE_AVAILABLE'
        ];
        
        return securityStatuses.includes(statusReport.status);
    }

    generateFIDOVulnerabilityId(entry, statusReport) {
        const aaid = entry.aaid || entry.aaguid || 'UNKNOWN';
        const statusType = statusReport.status;
        const dateStr = new Date(statusReport.effectiveDate).toISOString().split('T')[0];
        
        return `FIDO-MDS-${statusType}-${aaid.slice(0, 8)}-${dateStr}`;
    }

    isKnownVulnerability(vulnerabilityId) {
        return this.knownVulnerabilities.vulnerabilities.some(vuln => vuln.id === vulnerabilityId);
    }

    createSecurityNoticeFromStatusReport(vulnerabilityId, authenticatorDescription, statusReport, metadataStatement) {
        const severityMapping = {
            'REVOKED': 'high',
            'USER_VERIFICATION_BYPASS': 'high', 
            'ATTESTATION_KEY_COMPROMISE': 'critical',
            'USER_KEY_REMOTE_COMPROMISE': 'critical',
            'USER_KEY_PHYSICAL_COMPROMISE': 'medium',
            'UPDATE_AVAILABLE': 'medium'
        };
        
        const cvssMapping = {
            'critical': 9.0,
            'high': 7.5,
            'medium': 5.5,
            'low': 3.0
        };
        
        const severity = severityMapping[statusReport.status] || 'medium';
        const cvssScore = cvssMapping[severity];
        
        return {
            id: vulnerabilityId,
            name: `FIDO ${statusReport.status}: ${authenticatorDescription}`,
            description: this.buildSecurityNoticeDescription(statusReport, metadataStatement),
            severity: severity,
            cvssScore: cvssScore,
            testImplemented: false,
            dateAdded: new Date().toISOString().split('T')[0],
            source: 'FIDO Alliance MDS',
            publishedDate: statusReport.effectiveDate,
            affectedComponents: this.extractFIDOAffectedComponents(statusReport, metadataStatement),
            mitigation: this.generateFIDOMitigation(statusReport),
            authenticatorInfo: {
                description: authenticatorDescription,
                aaguid: metadataStatement.aaguid,
                protocolFamily: metadataStatement.protocolFamily
            }
        };
    }

    buildSecurityNoticeDescription(statusReport, metadataStatement) {
        const statusDescriptions = {
            'REVOKED': 'Authenticator has been revoked due to security concerns',
            'USER_VERIFICATION_BYPASS': 'Vulnerability allows bypassing user verification',
            'ATTESTATION_KEY_COMPROMISE': 'Attestation private key has been compromised',
            'USER_KEY_REMOTE_COMPROMISE': 'User authentication key can be compromised remotely',
            'USER_KEY_PHYSICAL_COMPROMISE': 'User authentication key can be compromised with physical access',
            'UPDATE_AVAILABLE': 'Security update available for this authenticator'
        };
        
        let description = statusDescriptions[statusReport.status] || 'Security notice from FIDO Alliance';
        
        if (statusReport.url) {
            description += `. More details: ${statusReport.url}`;
        }
        
        if (statusReport.certificate) {
            description += ' Certificate-related security issue.';
        }
        
        return description;
    }

    extractFIDOAffectedComponents(statusReport, metadataStatement) {
        const components = ['fido authenticator'];
        
        if (statusReport.status.includes('USER_VERIFICATION')) {
            components.push('user verification');
        }
        
        if (statusReport.status.includes('ATTESTATION')) {
            components.push('attestation');
        }
        
        if (statusReport.status.includes('KEY_COMPROMISE')) {
            components.push('cryptographic keys');
        }
        
        if (metadataStatement?.protocolFamily) {
            components.push(`${metadataStatement.protocolFamily.toLowerCase()} protocol`);
        }
        
        return components;
    }

    generateFIDOMitigation(statusReport) {
        const mitigations = {
            'REVOKED': 'Remove this authenticator from allow-lists and reject its attestations',
            'USER_VERIFICATION_BYPASS': 'Require additional verification or disable this authenticator model',
            'ATTESTATION_KEY_COMPROMISE': 'Reject attestations from this authenticator model',
            'USER_KEY_REMOTE_COMPROMISE': 'Require re-registration of affected users with different authenticators',
            'USER_KEY_PHYSICAL_COMPROMISE': 'Educate users about physical security and consider additional protections',
            'UPDATE_AVAILABLE': 'Notify users to update their authenticator firmware'
        };
        
        let mitigation = mitigations[statusReport.status] || 'Review FIDO Alliance guidance';
        
        if (statusReport.url) {
            mitigation += `. See: ${statusReport.url}`;
        }
        
        return mitigation;
    }

    generateTestForVulnerability(vulnerability) {
        const testFunctionName = this.generateTestFunctionName(vulnerability.id);
        
        const testTemplate = `
    @Test
    @DisplayName("Should protect against ${vulnerability.id}")
    fun \`${testFunctionName}\`() = testApplication {
        application {
            module(testStorageModule)
        }
        
        val username = WebAuthnTestHelpers.generateTestUsername("${vulnerability.id.toLowerCase()}_test")
        val keyPair = WebAuthnTestHelpers.generateTestKeypair()
        
        // TODO: Implement specific test for ${vulnerability.name}
        // Vulnerability: ${vulnerability.description}
        // Severity: ${vulnerability.severity}
        // Mitigation: ${vulnerability.mitigation}
        
        assertTrue(true, "Implement test for ${vulnerability.id}")
    }`;
        
        return testTemplate.trim();
    }

    generateTestFunctionName(vulnerabilityId) {
        return `test protection against ${vulnerabilityId.toLowerCase().replace(/[^a-z0-9]/g, '_')}`;
    }

    async updateVulnerabilityTests(newVulnerabilities) {
        if (newVulnerabilities.length === 0) {
            console.log('âœ… No new vulnerabilities found');
            return false;
        }

        console.log(`ðŸ“ Found ${newVulnerabilities.length} new vulnerabilities, updating tests...`);
        
        const testFilePath = path.join(__dirname, '../src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt');
        let testContent = fs.readFileSync(testFilePath, 'utf8');
        
        // Find insertion point (before the final closing brace of the class)
        const insertionPoint = testContent.lastIndexOf('}');
        
        let newTestMethods = '';
        for (const vuln of newVulnerabilities) {
            newTestMethods += `
${this.generateTestForVulnerability(vuln)}

`;
        }
        
        // Insert new test methods before the final closing brace
        const updatedContent = testContent.slice(0, insertionPoint) + 
                              newTestMethods + 
                              testContent.slice(insertionPoint);
        
        fs.writeFileSync(testFilePath, updatedContent);
        
        // Update vulnerability tracking
        this.knownVulnerabilities.vulnerabilities.push(...newVulnerabilities);
        this.knownVulnerabilities.lastCheck = new Date().toISOString();
        fs.writeFileSync(this.vulnerabilityFile, JSON.stringify(this.knownVulnerabilities, null, 2));
        
        return true;
    }

    async createPullRequest(vulnerabilities) {
        console.log('ðŸš€ Creating pull request for vulnerability updates...');
        
        const branchName = `security/vulnerability-updates-${Date.now()}`;
        const commitMessage = `Add tests for ${vulnerabilities.length} new WebAuthn vulnerabilities

Added protection tests for:
${vulnerabilities.map(v => `- ${v.id}: ${v.name}`).join('\n')}

ðŸ¤– Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>`;

        try {
            // Create and switch to new branch
            await this.runGitCommand('checkout', ['-b', branchName]);
            console.log(`âœ… Created and switched to branch: ${branchName}`);
            
            // Add changed files
            await this.runGitCommand('add', [
                'src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt',
                'vulnerability-tracking.json'
            ]);
            console.log('âœ… Added changed files to staging');
            
            // Commit changes
            await this.runGitCommand('commit', ['-m', commitMessage]);
            console.log('âœ… Committed changes');
            
            // Push to remote
            await this.runGitCommand('push', ['-u', 'origin', branchName]);
            console.log(`âœ… Pushed branch ${branchName} to remote`);
            
            // Create pull request
            const prResult = await this.createGitHubPullRequest(branchName, commitMessage, vulnerabilities);
            
            return {
                branch: branchName,
                commit: commitMessage,
                filesChanged: ['VulnerabilityProtectionTest.kt', 'vulnerability-tracking.json'],
                pullRequestUrl: prResult.url,
                pullRequestNumber: prResult.number
            };
            
        } catch (error) {
            console.error(`âŒ Failed to create pull request: ${error.message}`);
            
            // Try to clean up the branch if something went wrong
            try {
                await this.runGitCommand('checkout', ['main']);
                await this.runGitCommand('branch', ['-D', branchName]);
                console.log(`ðŸ§¹ Cleaned up branch ${branchName} after failure`);
            } catch (cleanupError) {
                console.warn(`âš ï¸  Failed to clean up branch: ${cleanupError.message}`);
            }
            
            throw error;
        }
    }

    async runGitCommand(command, args = []) {
        return new Promise((resolve, reject) => {
            const git = spawn('git', [command, ...args], {
                cwd: path.join(__dirname, '..'),
                stdio: ['ignore', 'pipe', 'pipe']
            });
            
            let stdout = '';
            let stderr = '';
            
            git.stdout.on('data', (data) => {
                stdout += data.toString();
            });
            
            git.stderr.on('data', (data) => {
                stderr += data.toString();
            });
            
            git.on('close', (code) => {
                if (code === 0) {
                    resolve(stdout.trim());
                } else {
                    reject(new Error(`Git command failed: ${command} ${args.join(' ')}\n${stderr}`));
                }
            });
            
            git.on('error', (error) => {
                reject(new Error(`Failed to spawn git process: ${error.message}`));
            });
        });
    }

    async createGitHubPullRequest(branchName, commitMessage, vulnerabilities) {
        const title = `Add security tests for ${vulnerabilities.length} new WebAuthn vulnerabilities`;
        const body = this.generatePullRequestBody(vulnerabilities, commitMessage);
        
        // Extract repository info from git remote
        const remoteUrl = await this.runGitCommand('config', ['--get', 'remote.origin.url']);
        const repoMatch = remoteUrl.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
        
        if (!repoMatch) {
            throw new Error('Could not parse GitHub repository from remote URL');
        }
        
        const [, owner, repo] = repoMatch;
        
        // Try to create PR via GitHub API
        return await this.createPullRequestViaAPI(owner, repo, branchName, title, body);
    }

    generatePullRequestBody(vulnerabilities, commitMessage) {
        const body = `## Summary

This automated pull request adds security tests for ${vulnerabilities.length} newly discovered WebAuthn vulnerabilities.

### New Vulnerabilities Detected

${vulnerabilities.map(v => `#### ${v.id}: ${v.name}
- **Severity**: ${v.severity} (CVSS: ${v.cvssScore})
- **Source**: ${v.source}
- **Description**: ${v.description}
- **Mitigation**: ${v.mitigation}
- **Affected Components**: ${v.affectedComponents.join(', ')}
`).join('\n')}

### Test Implementation Status

${vulnerabilities.map(v => `- [ ] ${v.id}: Test stub created, manual implementation required`).join('\n')}

### Next Steps

1. Review each vulnerability for relevance to our WebAuthn implementation
2. Implement specific test cases for each vulnerability
3. Update security documentation if needed
4. Consider if any configuration changes are required

### Automated Changes

- Added test stubs to \`VulnerabilityProtectionTest.kt\`
- Updated vulnerability tracking in \`vulnerability-tracking.json\`

---

ðŸ¤– This PR was automatically generated by the vulnerability monitoring system.

**Important**: These are test stubs that require manual implementation. Do not merge without implementing the actual security tests.`;

        return body;
    }

    async createPullRequestViaAPI(owner, repo, branchName, title, body) {
        const apiUrl = `https://api.github.com/repos/${owner}/${repo}/pulls`;
        
        const pullRequestData = {
            title: title,
            head: branchName,
            base: 'main',
            body: body,
            draft: true // Create as draft since manual implementation is required
        };
        
        return new Promise((resolve, reject) => {
            const postData = JSON.stringify(pullRequestData);
            
            const options = {
                hostname: 'api.github.com',
                port: 443,
                path: `/repos/${owner}/${repo}/pulls`,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': Buffer.byteLength(postData),
                    'User-Agent': 'WebAuthn-Vulnerability-Monitor/1.0',
                    'Accept': 'application/vnd.github+json'
                }
            };
            
            // Check for GitHub token
            const githubToken = process.env.GITHUB_TOKEN;
            if (githubToken) {
                options.headers['Authorization'] = `Bearer ${githubToken}`;
            } else {
                console.warn('âš ï¸  No GITHUB_TOKEN environment variable found. PR creation may fail.');
                console.warn('   Set GITHUB_TOKEN to create PRs automatically, or create manually from the pushed branch.');
            }
            
            const req = https.request(options, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    try {
                        if (res.statusCode === 201) {
                            const prData = JSON.parse(data);
                            console.log(`âœ… Created GitHub pull request: ${prData.html_url}`);
                            resolve({
                                url: prData.html_url,
                                number: prData.number
                            });
                        } else if (res.statusCode === 401) {
                            console.warn('âš ï¸  GitHub API authentication failed. PR creation skipped.');
                            console.warn(`   Branch ${branchName} was pushed. Create PR manually: https://github.com/${owner}/${repo}/compare/${branchName}`);
                            resolve({
                                url: `https://github.com/${owner}/${repo}/compare/${branchName}`,
                                number: null,
                                manual: true
                            });
                        } else {
                            const errorData = JSON.parse(data);
                            reject(new Error(`GitHub API error (${res.statusCode}): ${errorData.message}`));
                        }
                    } catch (error) {
                        reject(new Error(`Failed to parse GitHub API response: ${error.message}`));
                    }
                });
            });
            
            req.on('error', (error) => {
                reject(new Error(`GitHub API request failed: ${error.message}`));
            });
            
            req.write(postData);
            req.end();
        });
    }

    async run() {
        console.log('ðŸ” Starting vulnerability monitoring check...');
        
        try {
            // First get the current library status to cross-reference with other sources
            const libraryStatus = await this.checkJavaWebAuthnServerDependency();
            const libraryData = await this.fetchJavaWebAuthnServerAdvisories();
            
            // Check all vulnerability sources with library context
            const [cveResults, yubicoResults, fidoResults] = await Promise.all([
                this.checkCVEDatabase(libraryData, libraryStatus),
                this.checkYubicoAdvisories(),
                this.checkFIDOAllianceNotices(libraryData, libraryStatus)
            ]);
            
            // Combine and deduplicate results
            const allNewVulns = [...cveResults, ...yubicoResults, ...fidoResults];
            const newVulnerabilities = allNewVulns.filter(vuln => 
                !this.knownVulnerabilities.vulnerabilities.some(known => known.id === vuln.id)
            );
            
            // Categorize actionable vs library-mitigated vulnerabilities
            const { actionableVulns, libraryMitigatedVulns } = this.categorizeVulnerabilities(newVulnerabilities, libraryData, libraryStatus);
            
            if (libraryMitigatedVulns.length > 0) {
                console.log(`ðŸ“š Found ${libraryMitigatedVulns.length} vulnerabilities already addressed by java-webauthn-server updates`);
                libraryMitigatedVulns.forEach(vuln => {
                    console.log(`   ${vuln.id}: ${vuln.libraryMitigation}`);
                });
            }
            
            // Only create tests/PRs for truly actionable vulnerabilities
            if (actionableVulns.length > 0) {
                const testsUpdated = await this.updateVulnerabilityTests(actionableVulns);
                
                if (testsUpdated) {
                    const prDetails = await this.createPullRequest(actionableVulns);
                    console.log('âœ… Vulnerability monitoring complete - PR created for review');
                    return prDetails;
                }
            }
            
            console.log('âœ… Vulnerability monitoring complete - no updates needed');
            return null;
            
        } catch (error) {
            console.error('âŒ Error during vulnerability monitoring:', error);
            throw error;
        }
    }
}

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
    const monitor = new VulnerabilityMonitor();
    monitor.run()
        .then((result) => {
            if (result) {
                console.log('PR Details:', result);
            }
            process.exit(0);
        })
        .catch((error) => {
            console.error('Monitoring failed:', error);
            process.exit(1);
        });
}

export default VulnerabilityMonitor;