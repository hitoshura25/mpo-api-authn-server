#!/usr/bin/env python3
"""
Vulnerability Categorizer - Security Domain Classification

Standalone module for categorizing vulnerabilities by security domain.
Used across multiple phases to ensure consistent categorization.
"""

import logging
from typing import Dict, Any, Tuple


class VulnerabilityCategorizor:
    """Categorizes vulnerabilities by security domain for specialized training."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

        # Tool-to-category mapping based on security scanner origin
        self.tool_category_map = {
            # Container Security
            'sarif-trivy': 'container_security',
            'trivy': 'container_security',

            # Infrastructure Security
            'sarif-checkov': 'infrastructure_security',
            'checkov': 'infrastructure_security',
            'sarif-gitleaks': 'infrastructure_security',
            'gitleaks': 'infrastructure_security',

            # Web Security
            'zap': 'web_security',
            'sarif-zap': 'web_security',

            # Dependency Vulnerabilities
            'osv-scanner': 'dependency_vulnerabilities',
            'sarif-osv': 'dependency_vulnerabilities',

            # Code Vulnerabilities & WebAuthn
            'semgrep': 'code_vulnerabilities',  # Default, refined by content analysis
            'sarif-semgrep': 'code_vulnerabilities',

            # Mobile Security (if applicable)
            'mobsf': 'mobile_security',
        }

        # WebAuthn-specific patterns for semgrep refinement
        self.webauthn_patterns = [
            'webauthn', 'fido', 'authenticator', 'credential',
            'attestation', 'assertion', 'challenge', 'passkey'
        ]

    def categorize_vulnerability(self, vulnerability: Dict[str, Any]) -> Tuple[str, float]:
        """
        Categorize vulnerability by security domain.

        Args:
            vulnerability: Vulnerability data with tool, description, file_path etc.

        Returns:
            Tuple of (category, confidence_score)

        Raises:
            ValueError: If tool is unknown (fail-fast behavior)
        """
        tool = vulnerability.get('tool', '').lower()
        vuln_id = vulnerability.get('id', 'unknown')

        # âœ… FAIL-FAST: No unknown tools allowed
        if not tool:
            raise ValueError(f"Vulnerability {vuln_id} missing 'tool' field. Cannot categorize.")

        if tool not in self.tool_category_map:
            supported_tools = list(self.tool_category_map.keys())
            raise ValueError(f"Unknown security tool '{tool}' for vulnerability {vuln_id}. "
                           f"Cannot categorize - pipeline must stop. "
                           f"Supported tools: {supported_tools}")

        # Get base category from tool mapping
        base_category = self.tool_category_map[tool]

        # Special handling for semgrep - check for WebAuthn patterns
        if base_category == 'code_vulnerabilities':
            webauthn_category, webauthn_confidence = self._check_webauthn_patterns(vulnerability)
            if webauthn_category:
                return webauthn_category, webauthn_confidence

        # Calculate confidence for base category
        confidence = self._calculate_confidence(vulnerability, base_category)

        return base_category, confidence

    def _check_webauthn_patterns(self, vulnerability: Dict[str, Any]) -> Tuple[str, float]:
        """Check if code vulnerability is WebAuthn-specific."""
        text_content = ' '.join([
            vulnerability.get('description', ''),
            vulnerability.get('message', ''),
            vulnerability.get('file_path', ''),
            str(vulnerability.get('metadata', {}))
        ]).lower()

        webauthn_matches = sum(1 for pattern in self.webauthn_patterns
                              if pattern in text_content)

        if webauthn_matches >= 2:  # Strong WebAuthn indication
            return 'webauthn_security', min(0.8 + (webauthn_matches * 0.05), 1.0)
        elif webauthn_matches == 1:  # Possible WebAuthn
            return 'webauthn_security', 0.6

        return None, 0.0

    def _calculate_confidence(self, vulnerability: Dict[str, Any], category: str) -> float:
        """Calculate confidence score for categorization."""
        confidence = 0.7  # Base confidence

        # Tool-specific confidence adjustments
        tool = vulnerability.get('tool', '').lower()

        # High confidence tools
        if tool in ['sarif-trivy', 'sarif-checkov', 'osv-scanner']:
            confidence = 0.9

        # Medium confidence tools
        elif tool in ['zap', 'gitleaks']:
            confidence = 0.8

        # Adjust based on content richness
        description = vulnerability.get('description', '')
        if len(description) > 100:
            confidence += 0.05

        if vulnerability.get('severity') in ['HIGH', 'CRITICAL', 'high', 'critical']:
            confidence += 0.05

        return min(confidence, 1.0)