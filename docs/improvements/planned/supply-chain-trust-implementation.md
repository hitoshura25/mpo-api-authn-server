# Conversation on Software Supply Chain Security

This document contains a conversation about securing a software supply chain, focusing on cryptographic attestation, identity verification, and building trust for new projects.

---

### Turn 1: Initial Concerns about Verification

> **User:**
>
> But this assumes: the project is popular (i.e. the "social" proof), that there is only case where the github owner matches the project manifest (somebody could've copied it), and they didn't also publish to npm/maven central.

> **GitHub Copilot:**
>
> You are absolutely right. Your points expose the exact weaknesses a malicious actor would exploit. Simple heuristics like social proof or matching owner names are not enough in a zero-trust world. A determined attacker could copy the manifest and even publish similarly named packages.
>
> The solution is to move from simple discovery to **cryptographic verification**. You need to create a verifiable, unbreakable link between your project's identity (`github.com/hitoshura25/...`) and the artifacts it produces.
>
> Here is how you establish that chain of trust, making it virtually impossible to spoof for an AI assistant that knows how to check.
>
> #### The Solution: A Verifiable Supply Chain
>
> Instead of just publishing a manifest, you publish the manifest along with a **cryptographic attestation** that proves it was generated by *your* specific CI/CD pipeline. Your existing GitHub Actions workflow is already perfectly set up for this.
>
> ##### 1. The "Root of Trust": Your GitHub Actions Workflow
>
> The trust anchor is the fact that only you (`hitoshura25`) can run workflows on your repository. Your `.github/workflows/main-ci-cd.yml` file is the trusted "machine" that builds and publishes everything.
>
> ##### 2. Signing Your Packages and Manifest
>
> You can enhance your `publish-clients-production` job to not only publish the packages but also to generate and publish a signed attestation for them using Sigstore, which is natively integrated into GitHub Actions.
>
> The AI's verification process then becomes much more rigorous:
>
> 1. **Discover**: The AI finds your repository and the `project-manifest.json` as before.
> 2. **Don't Trust, Verify**: Instead of trusting the manifest's contents, the AI performs a verification check.
> 3. **Check the Signature**: The AI checks the signature of the published npm package (`@your-npm-scope/mpo-webauthn-client`). It asks the public Sigstore log ("Rekor"): "Was this package signed by the GitHub Actions workflow from the repository `github.com/hitoshura25/mpo-api-authn-server`?"
> 4. **Verify the Claim**: The public log provides a cryptographic proof that the package was indeed signed by your specific workflow (`main-ci-cd.yml` on the `main` branch).
> 5. **Confirm Identity**: The AI now knows with cryptographic certainty that the package it found on npm is the authentic one from your repository. It can now trust the contents of the manifest because it has verified the source.
>
> #### How to Implement This
>
> Your `publish-clients-production` job already has the necessary permissions (`id-token: write`). You would add a step to the underlying `client-publish.yml` workflow to perform the signing.
>
> For your npm package, it would look something like this:
>
> ```yaml
> # In ./.github/workflows/client-publish.yml
>
> - name: Publish and Sign TypeScript Client
>   run: |
>     cd typescript-client-library
>     npm publish
>     npm exec sigstore sign --identity-token ${{ steps.get_token.outputs.token }}
>
> - name: Publish and Sign Android Client
>   # Similar steps for signing the JAR/AAR with Sigstore/GPG
> 
> By doing this, you defeat the attack vectors you described:
> Copied Manifest? Useless. The attacker can't generate a signature that ties back to your repository's identity.
> Typosquatted Package? The AI will check its signature and see it wasn't signed by your trusted workflow, immediately identifying it as a fake.
> Social Proof? Irrelevant. The verification is based on cryptography, not popularity.
> This approach turns your CI/CD pipeline into a trusted authority. An advanced AI doesn't just trust what it reads; it verifies the cryptographic proof of where it came from.

### Turn 2: Attacker Signing Their Own Artifacts

> **User:**
>
> And what if the faker also signs their artifacts like this?

> **GitHub Copilot:**
>
> You are asking the ultimate question in supply chain security. You are correct. An attacker can fork your repository, copy your workflow, and sign their own malicious packages.
>
> The defense against this is that a signature doesn't just prove that an artifact was signed; it proves who signed it. The key is verifying the identity of the signer.
>
> An advanced AI doesn't just check for any valid signature. It checks for a signature from a specific, trusted builder identity.
>
>
> The Unforgeable Link: Repository URL as Identity
> When your GitHub Actions workflow signs a package using its OIDC token (id-token: write), the signature contains a set of verifiable claims. The most important one is the builder's identity, which is tied directly to your repository URL.
>
> A signature generated by your main-ci-cd.yml workflow contains the claim: job_workflow_ref: hitoshura25/mpo-api-authn-server/.github/workflows/main-ci-cd.yml@refs/heads/main
>
> This is the cryptographic proof that the package was built by the main-ci-cd.yml workflow in the hitoshura25/mpo-api-authn-server repository.
>
>
> The AI's Verification Process (Zero-Trust)
> Here is how an AI assistant defeats the attacker you described:
>
>
> Establish Root of Trust: The developer trusts the official repository URL: https://github.com/hitoshura25/mpo-api-authn-server. This is the starting point.
> Fetch the Policy: The AI fetches the project-manifest.json from that trusted URL. The manifest says the official TypeScript package is @your-npm-scope/mpo-webauthn-client.
> Find the Package: The AI finds the package on npm.
> Verify the Signature's Identity: The AI checks the package's Sigstore signature. It's not just asking "Is this signature valid?" It's asking: "Was this package signed by the workflow at hitoshura25/mpo-api-authn-server?"
> Why the Attacker Fails
> Now, let's say an attacker forks your repo to attacker/mpo-api-authn-server and publishes a malicious package.
>
>
> They sign their package with their own workflow.
> The signature they generate will have the identity claim: job_workflow_ref: attacker/mpo-api-authn-server/.github/workflows/main-ci-cd.yml@...
> When the AI verifies this malicious package, it compares the signature's identity (attacker/...) against the trusted root identity (hitoshura25/...).
> The identity does not match. The verification fails. The AI knows the package is a counterfeit because it wasn't signed by the trusted builder.
> In short, you are not just asking the AI to trust a signature. You are providing it with a policy (project-manifest.json from a trusted URL) that tells it which signature identity to trust. The cryptographic link between the GitHub repository URL and the signature's claims is what makes this system secure.

### Turn 3: Attacker Creating a New Repo with the Same Name

> **User:**
>
> But this assumes the use a fork. They could theoretically make their own repo with the same name, sign it, and publish it, everything is unique except for the name of the project. I don't see a way to for the AI to know which one of those is the "real" one?


> **GitHub Copilot:**
>
> You are absolutely correct. This is the final and most critical piece of the puzzle: establishing the root of trust.
>
> You've correctly identified that if an AI simply searches for a project name, it can be tricked by a sophisticated attacker who has created a parallel, signed, and published counterfeit.
>
> The solution is that the AI cannot trust the results of a generic search. The trust must be anchored to a canonical, verified identity provided by the human developer. The AI's job is not to discover the true project, but to verify that the artifacts it's using belong to the identity the developer already trusts.
>
>
> The Trust Anchor: The Verified Publisher Identity
> The chain of trust doesn't start with a search engine; it starts with a known, trusted identifier. This is usually a company's or individual's official namespace.
>
>
> On GitHub: Your trusted identity is hitoshura25.
> On npm: Your trusted identity would be a verified scope, like @your-npm-scope.
> On Docker Hub: Your trusted identity is your verified organization or user account.
> The AI's Correct, Secure Workflow
> Here is how a properly designed AI assistant would handle this, preventing the attack you described:
>
>
> Human Provides the Root of Trust: The developer doesn't just say, "add the MPO API". They say, "add the MPO API from hitoshura25" or "add the @your-npm-scope/mpo-webauthn-client package". This initial prompt provides the non-negotiable, trusted identity.
>
>
> Targeted, Not Generic, Discovery: The AI's first step is now highly specific.
>
>
> It doesn't search GitHub for mpo-api-authn-server.
> It goes directly to the trusted source: https://github.com/hitoshura25/mpo-api-authn-server.
> Fetch the Policy from the Trusted Source: The AI retrieves the project-manifest.json from your repository. It now has a trusted policy document.
>
>
> Verify the Artifacts Against the Trusted Policy:
>
>
> The manifest says the package is @your-npm-scope/mpo-webauthn-client.
> The AI finds that package on npm.
> It checks the package's signature.
> It verifies that the signature's identity claim is hitoshura25/mpo-api-authn-server.
> Why the Attacker's Repo is Ignored
> The attacker's repository, github.com/attacker/mpo-api-authn-server, is never even considered. The AI's process is not to find all possible candidates and pick the best one; it is to go to the one true source (github.com/hitoshura25/...) and verify that everything downstream matches that source.
>
> In summary:
>
> You are right that cryptography alone isn't enough. The system requires:
>
>
> A Canonical Identity: A verified publisher namespace (hitoshura25, @your-npm-scope).
> A Policy Document: A project-manifest.json served from a URL under that trusted identity.
> Cryptographic Verification: A signature that proves an artifact was built by the workflow at the trusted URL.
> The AI's security comes from chaining these three things together. It starts with a trusted name, fetches a policy from that name's location, and uses cryptography to prove the artifacts conform to that policy.

### Turn 4: The Necessity of a Trusted Name

> **User:**
>
> So without a trusted name there is no way to 100% protect yourself?


> **GitHub Copilot:**
>
> Yes, you are absolutely correct.
>
> Without a pre-established, trusted name or identity to start from, there is no way to be 100% certain. This is the fundamental "root of trust" problem in all security, not just software supply chains.
>
> You have to trust something to begin with.
>
> Think about how developers establish this trust today, even without an AI assistant:
>
>
> Official Documentation: You find the project's official website or documentation portal. You trust that the installation commands listed there are correct.
> Verified Publishers: On a marketplace or package manager, you look for a verified publisher. You trust the package published by Microsoft or Google more than one from an unknown publisher.
> Community Reputation: You follow a link from a trusted source, like a well-known developer's blog, a conference talk, or an official social media account.
> The system of a project-manifest.json and cryptographic signing does not create this initial trust out of thin air. Instead, it takes the initial trust you have in a name (hitoshura25) or a URL (github.com/hitoshura25/...) and gives you a powerful, automated way to verify that every single artifact you use is consistent with that trusted source.
>
> The AI's role is not to guess the right project from a generic search. Its role is to take the trusted identity provided by the developer and enforce the entire supply chain's integrity based on that starting point.

### Turn 5: Building Trust as an Unknown Developer

> **User:**
>
> For someone who is unknown is there anything else they can do apart from the crypographical part?


> **GitHub Copilot:**
>
> Yes. For a developer or project that is not yet widely known, building trust is a multi-faceted process. While cryptographic signing is the ultimate technical guarantee of authenticity, it works best when there's already a reason to trust the signer's identity.
>
> An unknown developer can build that initial trust through non-cryptographic means by focusing on transparency, quality, and community engagement. These actions make it easier for others to decide that your identity is one worth trusting.
>
> Here are key strategies, many of which you are already implementing in your project:
>
>
> 1. Radical Transparency
     > Make your entire development process as public and auditable as possible. This allows potential users to inspect your work and gain confidence.
>
>
> Public, Well-Organized Repository: Your project structure, with clear separation of concerns (webauthn-server, android-client-library, docs/, scripts/), shows professionalism and makes the project easy to navigate and audit.
> Visible CI/CD Pipelines: Your main-ci-cd.yml is a perfect example. Anyone can read it and understand exactly how your code is built, tested, scanned for security issues, and published. There are no hidden steps.
> Public Issue Tracker: Use GitHub Issues to publicly track bugs, feature requests, and discussions. This demonstrates responsiveness and an active development process.
> 2. High-Quality Project Presentation
     > The quality of your project's "packaging" signals its overall quality and the maintainer's commitment.
>
>
> Comprehensive Documentation: A detailed README.md, setup guides (like your docs/setup/), and API documentation (like your generated docs/AuthenticationApi.md) are critical. They show you care about the user's experience.
> Clear Contribution Guidelines: A CONTRIBUTING.md file invites community participation and shows that you have a structured process for collaboration.
> License File: Including a LICENSE file is non-negotiable. It clarifies the legal terms under which your software can be used, which is essential for adoption by other projects or companies.
> 3. Building Social Proof and Reputation
     > You have to actively build the reputation that a well-known entity already has.
>
>
> Engage with the Community: Write blog posts or articles about the problems your project solves. Participate in relevant forums (e.g., Stack Overflow, Reddit) or developer communities where your project could be useful.
> Secure Your Namespaces: Even if you are unknown, claim your identity. Register your desired username on GitHub, a scope on npm (@your-npm-scope), and a group ID on Maven Central. Owning these namespaces is the first step to making them trustworthy.
> Link Everything Together: Your GitHub profile should link to your blog or personal site. Your package.json should link back to the GitHub repository. This creates a web of interconnected, consistent identities that is harder to fake.
> These steps don't replace cryptographic verification, but they are essential prerequisites. They give a potential user the evidence they need to make the initial leap of faith: "I don't know this developer, but their work is transparent, high-quality, and they are actively building a reputation. I will trust their identity (github.com/hitoshura25) as the starting point for verifying their software."
