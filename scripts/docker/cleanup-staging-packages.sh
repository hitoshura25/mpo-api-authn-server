#!/bin/bash
#
# GitHub Packages Staging Cleanup Script
#
# This script cleans up staging artifacts from GitHub Packages after main CI/CD completion.
# It targets ONLY staging packages and provides different cleanup strategies based on workflow outcome.
# Configuration is loaded from a central YAML file with environment variable override support.
#
# CLEANUP SCOPE - ONLY GitHub Packages:
# - GHCR (GitHub Container Registry): Staging Docker images
# - GitHub Packages npm: Staging packages (*-staging suffix)  
# - GitHub Packages Maven: Staging packages (*-staging suffix)
# - Does NOT touch external registries (Maven Central, DockerHub, npm registry)
#
# STANDARD TAG STRATEGY (August 2025):
# Simplified to use standard Docker tags generated by docker/metadata-action:
# - PR builds: pr-{pr-number} (e.g., pr-47)
# - Main builds: latest
# - This provides sufficient targeting for cleanup while improving performance.
#
# CLEANUP LOGIC:
# - On Successful Workflow: DELETE ALL staging packages (validation complete)
# - On Failed Workflow: Standard cleanup (keep last 5 versions for debugging)
# - Emergency Override: [preserve] keyword skips cleanup entirely
#
# USAGE:
#   ./cleanup-staging-packages.sh [success|failure] [repository_owner]
#
# For local testing and debugging, use: scripts/testing/client-publishing/test-local-cleanup.sh
#
# ENVIRONMENT VARIABLES:
#   GH_TOKEN - GitHub token with packages:write permission (required)
#   GITHUB_REPOSITORY_OWNER - Repository owner (if not provided as argument)
#   PRESERVE_STAGING - Set to 'true' to skip all cleanup (emergency override)
#   CONFIG_FILE - Path to central configuration file (default: config/publishing-config.yml)
#
# CONFIGURATION OVERRIDES (optional - defaults loaded from central config):
#   ANDROID_GROUP_ID - Maven group ID for Android packages
#   ANDROID_BASE_ARTIFACT_ID - Base artifact ID for Android packages
#   TYPESCRIPT_SCOPE - npm scope for TypeScript packages
#   TYPESCRIPT_BASE_PACKAGE_NAME - Base package name for TypeScript packages
#   ANDROID_STAGING_SUFFIX - Suffix for Android staging packages
#   NPM_STAGING_SUFFIX - Suffix for npm staging packages
#   AUTHOR_ID - Author identifier for repository references
#   DOCKER_WEBAUTHN_IMAGE_NAME - WebAuthn server Docker image name
#   DOCKER_TEST_CREDENTIALS_IMAGE_NAME - Test credentials service Docker image name
#
# EXIT CODES:
#   0 - Success (cleanup completed or skipped)
#   1 - Error occurred during cleanup
#
# DEBUGGING DELETION FAILURES:
# If cleanup fails during deletion, use manual testing mode to diagnose:
#   1. Run script in discovery mode to find packages and version IDs
#   2. Use manual testing mode to test deletion of specific version
#   3. Check token permissions (packages:write required)
#   4. Verify API endpoint format and authentication
#

set -euo pipefail

# Production mode only
WORKFLOW_OUTCOME="${1:-success}"
REPOSITORY_OWNER="${2:-${GITHUB_REPOSITORY_OWNER:-}}"

# Central configuration file path
CONFIG_FILE="${CONFIG_FILE:-config/publishing-config.yml}"

# Load central configuration using yq
load_central_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log "‚ùå Error: Configuration file not found: $CONFIG_FILE"
        exit 1
    fi
    
    if ! command -v yq &> /dev/null; then
        log "‚ùå Error: yq is not installed (required for configuration loading)"
        exit 1
    fi
    
    log "üìã Loading central configuration from: $CONFIG_FILE"
    
    # Load configuration values with environment variable overrides
    ANDROID_GROUP_ID="${ANDROID_GROUP_ID:-$(yq eval '.packages.android.groupId' "$CONFIG_FILE")}"
    ANDROID_BASE_ARTIFACT_ID="${ANDROID_BASE_ARTIFACT_ID:-$(yq eval '.packages.android.baseArtifactId' "$CONFIG_FILE")}"
    
    TYPESCRIPT_SCOPE="${TYPESCRIPT_SCOPE:-$(yq eval '.packages.typescript.scope.staging' "$CONFIG_FILE")}"
    TYPESCRIPT_BASE_PACKAGE_NAME="${TYPESCRIPT_BASE_PACKAGE_NAME:-$(yq eval '.packages.typescript.basePackageName' "$CONFIG_FILE")}"
    
    ANDROID_STAGING_SUFFIX="${ANDROID_STAGING_SUFFIX:-$(yq eval '.naming.staging.androidSuffix' "$CONFIG_FILE")}"
    NPM_STAGING_SUFFIX="${NPM_STAGING_SUFFIX:-$(yq eval '.naming.staging.npmSuffix' "$CONFIG_FILE")}"
    
    AUTHOR_ID="${AUTHOR_ID:-$(yq eval '.metadata.author.id' "$CONFIG_FILE")}"
    
    # Docker image names (just the image names, not full paths)
    DOCKER_WEBAUTHN_IMAGE_NAME="${DOCKER_WEBAUTHN_IMAGE_NAME:-webauthn-server}"
    DOCKER_TEST_CREDENTIALS_IMAGE_NAME="${DOCKER_TEST_CREDENTIALS_IMAGE_NAME:-webauthn-test-credentials-service}"
    
    # Docker registry for image preservation logging (defaults to GitHub Container Registry)
    DOCKER_REGISTRY="${DOCKER_REGISTRY:-ghcr.io}"
    
    # Construct full package names
    ANDROID_STAGING_PACKAGE="${ANDROID_GROUP_ID}.${ANDROID_BASE_ARTIFACT_ID}${ANDROID_STAGING_SUFFIX}"
    NPM_STAGING_PACKAGE_NAME="${TYPESCRIPT_BASE_PACKAGE_NAME}${NPM_STAGING_SUFFIX}"
    NPM_SCOPE_CLEAN="${TYPESCRIPT_SCOPE#@}"  # Remove @ prefix for scope
    
    # Validate required configuration
    validate_config
}

# Function to validate configuration values
validate_config() {
    local errors=0
    
    # Check for null or empty values from yq
    if [[ "$ANDROID_GROUP_ID" == "null" || -z "$ANDROID_GROUP_ID" ]]; then
        log "‚ùå Error: Android groupId not found in configuration"
        ((errors++))
    fi
    
    if [[ "$ANDROID_BASE_ARTIFACT_ID" == "null" || -z "$ANDROID_BASE_ARTIFACT_ID" ]]; then
        log "‚ùå Error: Android baseArtifactId not found in configuration"
        ((errors++))
    fi
    
    if [[ "$TYPESCRIPT_SCOPE" == "null" || -z "$TYPESCRIPT_SCOPE" ]]; then
        log "‚ùå Error: TypeScript scope not found in configuration"
        ((errors++))
    fi
    
    if [[ "$TYPESCRIPT_BASE_PACKAGE_NAME" == "null" || -z "$TYPESCRIPT_BASE_PACKAGE_NAME" ]]; then
        log "‚ùå Error: TypeScript basePackageName not found in configuration"
        ((errors++))
    fi
    
    if [[ "$AUTHOR_ID" == "null" || -z "$AUTHOR_ID" ]]; then
        log "‚ùå Error: Author ID not found in configuration"
        ((errors++))
    fi
    
    if [[ $errors -gt 0 ]]; then
        log "‚ùå Configuration validation failed with $errors errors"
        exit 1
    fi
    
    log "‚úÖ Configuration validation complete:"
    log "  Repository Owner: $REPOSITORY_OWNER"
    log "  GitHub Repository: ${GITHUB_REPOSITORY:-NOT_SET}"
    log "  Constructed Repo Path: ${GITHUB_REPOSITORY:-${REPOSITORY_OWNER}/repo}"
    log "  Android Group ID: $ANDROID_GROUP_ID"
    log "  Android Base Artifact ID: $ANDROID_BASE_ARTIFACT_ID"
    log "  Android Staging Suffix: $ANDROID_STAGING_SUFFIX"
    log "  TypeScript Scope: $TYPESCRIPT_SCOPE"
    log "  TypeScript Base Package: $TYPESCRIPT_BASE_PACKAGE_NAME"
    log "  npm Staging Suffix: $NPM_STAGING_SUFFIX"
    log "  Author ID: $AUTHOR_ID"
    log "  Docker WebAuthn Image: $DOCKER_WEBAUTHN_IMAGE_NAME"
    log "  Docker Test Credentials Image: $DOCKER_TEST_CREDENTIALS_IMAGE_NAME"
    log "  Constructed Android Staging Package: $ANDROID_STAGING_PACKAGE"
    log "  Constructed npm Staging Package: $NPM_STAGING_PACKAGE_NAME"
    log "  npm Scope (clean): $NPM_SCOPE_CLEAN"
    log "  npm Scoped Package (URL-encoded): ${NPM_SCOPE_CLEAN}%2F${NPM_STAGING_PACKAGE_NAME}"
}

# Emergency override check
if [[ "${PRESERVE_STAGING:-false}" == "true" ]]; then
    echo "üö® EMERGENCY OVERRIDE: PRESERVE_STAGING=true - Skipping all staging cleanup"
    echo "‚ö†Ô∏è  All staging packages will be preserved for manual investigation"
    exit 0
fi

# Function to log with timestamp
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*"
}

# Function to determine cleanup scope based on context
determine_cleanup_scope() {
    local event_name="${GITHUB_EVENT_NAME:-}"
    local pr_number="${GITHUB_PR_NUMBER:-}"
    local ref_name="${GITHUB_REF_NAME:-}"
    
    log "üîç Determining cleanup scope from context:"
    log "  Event Name: ${event_name:-'NOT_SET'}"
    log "  PR Number: ${pr_number:-'NOT_SET'}"
    log "  Ref Name: ${ref_name:-'NOT_SET'}"
    
    # Determine cleanup context
    if [[ "$event_name" == "pull_request" && -n "$pr_number" ]]; then
        # PR context - clean only current PR packages
        CLEANUP_CONTEXT="pr"
        CLEANUP_PR_NUMBER="$pr_number"
        log "‚úÖ Context: PR #${pr_number} - will target only pr-${pr_number} packages"
    elif [[ "$event_name" == "push" && "$ref_name" == "main" ]]; then
        # Main branch context - determine which PR packages to clean
        CLEANUP_CONTEXT="main"
        CLEANUP_PR_NUMBER=""
        
        # For main branch, we could look at recent merge commits to find the PR number
        # For now, we'll use a more conservative approach and clean recent staging packages
        local recent_pr_from_merge
        recent_pr_from_merge=$(git log -1 --pretty=%s | grep -oE '#[0-9]+' | head -1 | tr -d '#' || echo "")
        
        if [[ -n "$recent_pr_from_merge" ]]; then
            # Use explicit value for main branch cleanup - this triggers ALL staging package cleanup
            # including both the merged PR packages AND the main branch packages that were just published
            CLEANUP_PR_NUMBER="MAIN_BRANCH"
            log "‚úÖ Context: Main branch (recent merge from PR #${recent_pr_from_merge}) - will target ALL staging packages including main branch"
        else
            CLEANUP_PR_NUMBER="MAIN_BRANCH"
            log "‚ö†Ô∏è Context: Main branch (no recent PR detected) - will target ALL staging packages"
        fi
    else
        # Unknown context - use broad staging pattern but log the issue
        CLEANUP_CONTEXT="unknown"
        CLEANUP_PR_NUMBER=""
        log "‚ö†Ô∏è Context: Unknown (event: ${event_name}, ref: ${ref_name}) - will use broad staging pattern"
        log "üîß Consider updating workflow to provide proper context variables"
    fi
    
    # Set global variables for use in cleanup functions
    export CLEANUP_CONTEXT
    export CLEANUP_PR_NUMBER
    
    log "üìã Final cleanup scope:"
    log "  Context: $CLEANUP_CONTEXT"
    log "  PR Number: ${CLEANUP_PR_NUMBER:-'NONE'}"
}

# Function to validate inputs
validate_inputs() {
    if [[ "$WORKFLOW_OUTCOME" != "success" && "$WORKFLOW_OUTCOME" != "failure" ]]; then
        log "‚ùå Error: Invalid workflow outcome: $WORKFLOW_OUTCOME"
        log "Usage: $0 [success|failure] [repository_owner]"
        exit 1
    fi
    
    if [[ -z "$REPOSITORY_OWNER" ]]; then
        if [[ -n "${GITHUB_REPOSITORY:-}" ]]; then
            REPOSITORY_OWNER="${GITHUB_REPOSITORY%%/*}"
        else
            log "‚ùå Error: Repository owner not specified"
            log "Usage: $0 [success|failure] [repository_owner]"
            log "Or set GITHUB_REPOSITORY_OWNER environment variable"
            exit 1
        fi
    fi
    
    log "‚úÖ Validation complete:"
    log "  Workflow outcome: $WORKFLOW_OUTCOME"
    log "  Repository owner: $REPOSITORY_OWNER"
}


# Function to validate GitHub CLI and authentication
validate_github_cli() {
    log "üîç Validating GitHub CLI setup..."
    
    if ! command -v gh &> /dev/null; then
        log "‚ùå Error: GitHub CLI (gh) is not installed"
        exit 1
    fi
    
    # Get detailed auth status for debugging
    local auth_status
    auth_status=$(gh auth status 2>&1 || echo "Auth check failed")
    log "üîç GitHub CLI auth status: $auth_status"
    
    if ! gh auth status &> /dev/null; then
        log "‚ùå Error: GitHub CLI is not authenticated"
        log "‚ùå Please run 'gh auth login' or set GH_TOKEN environment variable"
        exit 1
    fi
    
    if [[ -z "${GH_TOKEN:-}" ]]; then
        log "‚ö†Ô∏è Warning: GH_TOKEN environment variable not set"
        log "Using default gh authentication"
    else
        log "‚úÖ GH_TOKEN environment variable is set"
    fi
    
    # Test GitHub API access with packages scope
    log "üîç Testing GitHub API access for packages..."
    local test_result
    if test_result=$(gh api /user 2>&1); then
        local username
        username=$(echo "$test_result" | jq -r '.login' 2>/dev/null || echo "unknown")
        log "‚úÖ GitHub API access confirmed for user: $username"
    else
        log "‚ùå GitHub API test failed: $test_result"
        log "‚ùå This may indicate insufficient token permissions"
    fi
    
    log "‚úÖ GitHub CLI authentication validated"
}

# Function to URL-encode package names for API calls
url_encode_package_name() {
    local package_name="$1"
    # URL encode forward slashes and other special characters that may appear in package names
    echo "$package_name" | sed 's|/|%2F|g' | sed 's| |%20|g'
}

# Function to find the correct API endpoint for a package
find_package_endpoint() {
    local package_type="$1"
    local package_name="$2"
    
    # URL-encode the package name for API calls
    local encoded_package_name
    encoded_package_name=$(url_encode_package_name "$package_name")
    
    # Use the endpoint patterns that were verified to work in testing
    local endpoints=()
    case "$package_type" in
        "container")
            # Docker/container packages - use user-scoped endpoints (verified working)
            endpoints=(
                "/users/${REPOSITORY_OWNER}/packages/container/${encoded_package_name}"
                "/orgs/${REPOSITORY_OWNER}/packages/container/${encoded_package_name}"
                "/user/packages/container/${encoded_package_name}"
            )
            ;;
        "npm")
            # npm packages - use user packages endpoint (verified working)
            endpoints=(
                "/user/packages/npm/${encoded_package_name}"
                "/orgs/${REPOSITORY_OWNER}/packages/npm/${encoded_package_name}"
                "/users/${REPOSITORY_OWNER}/packages/npm/${encoded_package_name}"
            )
            ;;
        "maven")
            # Maven packages - use user packages endpoint (verified working)
            endpoints=(
                "/user/packages/maven/${encoded_package_name}"
                "/orgs/${REPOSITORY_OWNER}/packages/maven/${encoded_package_name}"
                "/users/${REPOSITORY_OWNER}/packages/maven/${encoded_package_name}"
            )
            ;;
        *)
            # Generic fallback for other package types
            endpoints=(
                "/user/packages/${package_type}/${encoded_package_name}"
                "/orgs/${REPOSITORY_OWNER}/packages/${package_type}/${encoded_package_name}"
                "/users/${REPOSITORY_OWNER}/packages/${package_type}/${encoded_package_name}"
            )
            ;;
    esac
    
    for endpoint in "${endpoints[@]}"; do
        # Send logging to stderr to avoid contaminating command substitution
        log "üîç Testing endpoint: $endpoint" >&2
        log "üîç Original package name: $package_name" >&2
        log "üîç URL-encoded package name: $encoded_package_name" >&2
        
        # Test endpoint with more robust error checking
        local api_test_result
        api_test_result=$(gh api "${endpoint}/versions" --silent 2>&1)
        local api_exit_code=$?
        
        if [[ $api_exit_code -eq 0 ]]; then
            log "‚úÖ Found package at: $endpoint" >&2
            
            # Verify the endpoint actually returns version data
            local version_count
            version_count=$(echo "$api_test_result" | jq 'length' 2>/dev/null || echo "0")
            log "üîç Endpoint verification: $version_count versions available" >&2
            
            # Only return the clean endpoint path to stdout
            echo "$endpoint"
            return 0
        else
            log "‚ùå Endpoint failed: $endpoint (exit code: $api_exit_code)" >&2
            if [[ "$api_test_result" =~ "404" ]]; then
                log "   Package not found at this endpoint" >&2
            elif [[ "$api_test_result" =~ "403" ]]; then
                log "   Permission denied - check token permissions" >&2
            else
                log "   Error details: $(echo "$api_test_result" | head -c 100)..." >&2
            fi
        fi
    done
    
    log "‚ùå Package not found at any endpoint: $package_name" >&2
    log "‚ùå Available endpoints tested:" >&2
    for endpoint in "${endpoints[@]}"; do
        log "   - $endpoint/versions" >&2
    done
    return 1
}

# Function to safely delete a Docker version with error recovery
delete_docker_version() {
    local endpoint="$1"
    local version_id="$2"
    local package_name="${3:-unknown}"
    
    if [[ -z "$version_id" || "$version_id" == "null" ]]; then
        log "‚ö†Ô∏è Skipping invalid version ID: '$version_id'"
        return 1
    fi
    
    # First, check if this is the last tagged version to avoid the error
    local total_tagged_versions
    total_tagged_versions=$(gh api "${endpoint}/versions" --jq '[.[] | select(.metadata.container.tags | length > 0)] | length' 2>/dev/null || echo "unknown")
    
    if [[ "$total_tagged_versions" == "1" ]]; then
        log "üîç Detected last tagged version - will delete entire package instead of individual version"
        log "üîÑ GitHub API restriction: Cannot delete last tagged version, must delete package"
        
        # Extract package path from endpoint for package deletion
        local package_path
        if [[ "$endpoint" =~ /users/([^/]+)/packages/container/([^/]+)$ ]]; then
            local owner="${BASH_REMATCH[1]}"
            local extracted_package_name="${BASH_REMATCH[2]}"
            package_path="/users/$owner/packages/container/$extracted_package_name"
            log "üîç Detected package path: $package_path"
            
            # Attempt to delete the entire package
            log "üóëÔ∏è Attempting to delete entire package: $extracted_package_name"
            local package_delete_result
            local package_delete_exit_code
            
            set +e
            package_delete_result=$(gh api --method DELETE "$package_path" 2>&1)
            package_delete_exit_code=$?
            set -e
            
            if [[ $package_delete_exit_code -eq 0 ]]; then
                log "‚úÖ Successfully deleted entire package: $extracted_package_name"
                log "‚úÖ Package delete response: $package_delete_result"
                return 0
            else
                log "‚ùå Failed to delete entire package: $extracted_package_name"
                log "‚ùå Package delete exit code: $package_delete_exit_code"
                log "‚ùå Package delete error: $package_delete_result"
                return 1
            fi
        else
            log "‚ùå Could not extract package information from endpoint: $endpoint"
            return 1
        fi
    fi
    
    log "üîç Attempting to delete Docker version ID: $version_id (package: $package_name)"
    log "üîç DELETE endpoint: ${endpoint}/versions/$version_id"
    log "üîç Total tagged versions in package: $total_tagged_versions"
    
    # Temporarily disable error exit for this operation
    set +e
    local delete_result
    local delete_exit_code
    
    # Attempt deletion with comprehensive error capture
    log "üîç Executing: gh api --method DELETE ${endpoint}/versions/$version_id"
    delete_result=$(gh api --method DELETE "${endpoint}/versions/$version_id" 2>&1)
    delete_exit_code=$?
    
    # Re-enable error exit
    set -e
    
    if [[ $delete_exit_code -eq 0 ]]; then
        log "‚úÖ Successfully deleted Docker version: $version_id"
        log "‚úÖ Delete response: $delete_result"
        return 0
    else
        log "‚ùå Failed to delete Docker version: $version_id"
        log "‚ùå Exit code: $delete_exit_code"
        log "‚ùå Full error response: $delete_result"
        
        # Enhanced error analysis
        if [[ "$delete_result" =~ "404" ]]; then
            log "‚ùå Error type: Version not found (404) - may have been deleted already"
        elif [[ "$delete_result" =~ "403" ]]; then
            log "‚ùå Error type: Permission denied (403) - check token permissions"
            log "‚ùå Required permissions: packages:write for GitHub Packages"
        elif [[ "$delete_result" =~ "401" ]]; then
            log "‚ùå Error type: Unauthorized (401) - check token authentication"
        elif [[ "$delete_result" =~ "422" ]]; then
            log "‚ùå Error type: Unprocessable entity (422) - invalid request format"
        elif [[ "$delete_result" =~ "400" ]]; then
            log "‚ùå Error type: Bad request (400) - may be last tagged version or other constraint"
            # Fallback: attempt package deletion if version count detection failed
            if [[ "$total_tagged_versions" == "unknown" ]]; then
                log "üîÑ Attempting package deletion as fallback for 400 error"
                local package_path
                if [[ "$endpoint" =~ /users/([^/]+)/packages/container/([^/]+)$ ]]; then
                    local owner="${BASH_REMATCH[1]}"
                    local extracted_package_name="${BASH_REMATCH[2]}"
                    package_path="/users/$owner/packages/container/$extracted_package_name"
                    
                    set +e
                    local fallback_result
                    fallback_result=$(gh api --method DELETE "$package_path" 2>&1)
                    local fallback_exit_code=$?
                    set -e
                    
                    if [[ $fallback_exit_code -eq 0 ]]; then
                        log "‚úÖ Fallback package deletion succeeded: $extracted_package_name"
                        return 0
                    else
                        log "‚ùå Fallback package deletion failed: $fallback_result"
                    fi
                fi
            fi
        elif [[ "$delete_result" =~ "500" ]] || [[ "$delete_result" =~ "502" ]] || [[ "$delete_result" =~ "503" ]]; then
            log "‚ùå Error type: Server error - GitHub API may be temporarily unavailable"
            log "üîÑ Consider retry with exponential backoff"
        else
            log "‚ùå Error type: Unknown - full response logged above"
        fi
        
        return 1
    fi
}

# Function to determine Docker cleanup strategy based on branch and context
determine_docker_cleanup_strategy() {
    local ref_name="${GITHUB_REF_NAME:-}"
    local force_cleanup="${FORCE_DOCKER_CLEANUP:-false}"
    
    log "üîç Determining Docker cleanup strategy:"
    log "  Branch/Ref: ${ref_name:-'NOT_SET'}"
    log "  Workflow Context: $CLEANUP_CONTEXT"
    log "  Force Cleanup: $force_cleanup"
    
    # Force override: Used by post-processing workflow after DockerHub publishing
    if [[ "$force_cleanup" == "true" ]]; then
        DOCKER_CLEANUP_STRATEGY="standard"
        log "üîÑ FORCE CLEANUP: Post-processing override - cleaning up preserved images"
        log "‚úÖ Final cleanup after DockerHub publishing completed"
        export DOCKER_CLEANUP_STRATEGY
        return 0
    fi
    
    # CRITICAL: Main branch Docker image preservation for production publishing
    if [[ "$ref_name" == "main" && "$CLEANUP_CONTEXT" == "main" ]]; then
        DOCKER_CLEANUP_STRATEGY="preserve"
        log "üö® MAIN BRANCH: Preserving Docker images for production publishing"
        log "üì¶ Images will be preserved until DockerHub publishing completes"
        log "üîÑ Post-processing workflow will handle final cleanup"
        export DOCKER_CLEANUP_STRATEGY
        return 0
    fi
    
    # All other contexts: standard cleanup
    DOCKER_CLEANUP_STRATEGY="standard"
    log "‚úÖ STANDARD CLEANUP: Docker images will be cleaned up immediately"
    log "üìã Context: PR builds, non-main branches, unknown contexts"
    export DOCKER_CLEANUP_STRATEGY
    return 0
}

# Function to clean up staging Docker images from GHCR
cleanup_staging_docker() {
    log "üê≥ Cleaning up staging Docker images from GHCR..."
    
    # Determine cleanup strategy first
    determine_docker_cleanup_strategy
    
    # Check if Docker cleanup should be skipped
    if [[ "$DOCKER_CLEANUP_STRATEGY" == "preserve" ]]; then
        log "üö® SKIPPING Docker image cleanup - preserving for production publishing"
        log "üì¶ Docker images preserved in GHCR for DockerHub publishing workflow"
        log "üîÑ main-ci-cd.yml production publishing will handle cleanup after publishing"
        log ""
        log "üìã Images preserved:"
        log "  - ${DOCKER_REGISTRY:-ghcr.io}/${REPOSITORY_OWNER}/${DOCKER_WEBAUTHN_IMAGE_NAME}:latest"
        log "  - ${DOCKER_REGISTRY:-ghcr.io}/${REPOSITORY_OWNER}/${DOCKER_TEST_CREDENTIALS_IMAGE_NAME}:latest"
        return 0
    fi
    
    log "üßπ Performing standard Docker cleanup strategy"
    
    local packages=("$DOCKER_WEBAUTHN_IMAGE_NAME" "$DOCKER_TEST_CREDENTIALS_IMAGE_NAME")
    local total_deleted=0
    local total_failed=0
    
    for package in "${packages[@]}"; do
        log "üîç Processing Docker package: $package"
        
        # Container packages in GHCR may use different naming patterns
        # Try both simple name and repository-scoped name
        local package_variants=(
            "$package"                                                    # Simple name: webauthn-server
            "${REPOSITORY_OWNER}/${package}"                             # Owner-scoped: hitoshura25/webauthn-server  
            "mpo-api-authn-server/${package}"                           # Repo-scoped: mpo-api-authn-server/webauthn-server
            "${REPOSITORY_OWNER}/mpo-api-authn-server/${package}"       # Full path: hitoshura25/mpo-api-authn-server/webauthn-server
        )
        
        local endpoint=""
        local found_package=""
        
        # Try each package name variant using the improved endpoint discovery
        for package_variant in "${package_variants[@]}"; do
            log "üîç Trying package variant: $package_variant"
            
            # Use the improved find_package_endpoint function
            if endpoint=$(find_package_endpoint "container" "$package_variant" 2>/dev/null); then
                found_package="$package_variant"
                log "‚úÖ Found Docker package: $found_package at $endpoint"
                break
            else
                log "   Package variant not found: $package_variant"
            fi
        done
        
        if [[ -z "$endpoint" ]]; then
            log "‚ö†Ô∏è Skipping Docker package (not found with any name variant): $package"
            log "   Tried variants: ${package_variants[*]}"
            continue
        fi
        
        log "üìç Using Docker endpoint: $endpoint"
        
        # Get staging versions based on workflow outcome and cleanup context
        local versions_query
        local strategy_description
        
        # Build the filter based on cleanup context
        local filter_conditions=""
        if [[ -n "$CLEANUP_PR_NUMBER" && "$CLEANUP_PR_NUMBER" != "MAIN_BRANCH" ]]; then
            # Target specific PR number with explicit SHA tags (no time-based guessing)
            # Uses explicit SHA tags created by Docker build workflow: sha256-{short-sha}-pr-{number}
            filter_conditions='
                (.metadata.container.tags[]? | test("^pr-'"$CLEANUP_PR_NUMBER"'$")) or
                (.metadata.container.tags[]? | test("^sha256-[a-f0-9]+-pr-'"$CLEANUP_PR_NUMBER"'$"))'
            strategy_description="TARGET PR #$CLEANUP_PR_NUMBER packages with explicit SHA tags"
            log "üéØ Targeting specific PR #$CLEANUP_PR_NUMBER packages"
            log "üéØ Using explicit SHA tags: sha256-*-pr-$CLEANUP_PR_NUMBER (no time-based guessing)"
        else
            # Fallback to broader staging pattern (legacy behavior for unknown contexts)  
            # Include 'latest' tag which is used by main branch builds to GitHub Packages (staging)
            filter_conditions='
                (.metadata.container.tags[]? | test("^pr-[0-9]+$")) or
                (.metadata.container.tags[]? | test("-staging$")) or
                (.metadata.container.tags[]? | test("^latest$")) or
                (.metadata.container.tags[]? | test("^sha256-[a-f0-9]+-pr-[0-9]+$")) or
                (.metadata.container.tags[]? | test("^sha256-[a-f0-9]+-main-[0-9]+$")) or
                (.metadata.container.tags[]? | test("^sha256-[a-f0-9]+-manual-[0-9]+$")) or
                (.metadata.container.tags[]? | test("^sha256-[a-f0-9]+-branch-.+-[0-9]+$"))'
            strategy_description="TARGET ALL staging packages (includes latest for main branch)"
            log "‚ö†Ô∏è Using broad staging pattern - no specific PR context"
            log "üéØ Targeting: pr-*, latest, *-staging, sha256-*-{pr|main|manual|branch}-* patterns"
        fi
        
        if [[ "$WORKFLOW_OUTCOME" == "success" ]]; then
            # Delete ALL matching staging images on success
            versions_query='.[] | select('"$filter_conditions"') | .id'
            log "  Strategy: DELETE ALL $strategy_description (workflow succeeded)"
        else
            # Keep last 5 matching staging versions on failure (for debugging)
            versions_query='[.[] | select('"$filter_conditions"')] | sort_by(.created_at) | reverse | .[5:] | .[].id'
            log "  Strategy: Keep last 5 of $strategy_description (workflow failed)"
        fi
        
        # Make API call to get package versions
        log "üîç Getting versions for package: $found_package"
        
        local version_response
        local api_exit_code
        
        # Make the API call with proper error handling
        if version_response=$(gh api "${endpoint}/versions" 2>&1); then
            api_exit_code=0
            log "‚úÖ API call successful"
        else
            api_exit_code=$?
            log "‚ùå API call failed for ${endpoint}/versions (exit code: $api_exit_code)"
            log "‚ùå Error response: $version_response"
            continue
        fi
        
        log "üîç Raw API response received (length: ${#version_response} chars)"
        
        local version_count
        version_count=$(echo "$version_response" | jq 'length' 2>/dev/null || echo "0")
        log "üîç Total versions found for $package: $version_count"
        
        if [[ "$version_count" -gt 0 ]]; then
            log "üîç Sample version details:"
            echo "$version_response" | jq -r '.[:3] | .[] | "  - ID: \(.id), Tags: \(.metadata.container.tags // [] | join(", ")), Created: \(.created_at)"' 2>/dev/null || log "  (Failed to get details)"
            
            # Show current staging versions specifically for debugging using same filter
            local current_staging
            current_staging=$(echo "$version_response" | jq -r '.[] | select('"$filter_conditions"') | "  - Staging: ID=\(.id), Tags=[\(.metadata.container.tags | join(","))], Created=\(.created_at)"' 2>/dev/null || echo "")
            if [[ -n "$current_staging" ]]; then
                log "üîç Current staging versions matching filter:"
                echo "$current_staging"
            else
                log "üîç No staging versions found matching current filter"
            fi
        fi
        
        local versions
        log "üîç Applying staging filter query..."
        versions=$(echo "$version_response" | jq -r "$versions_query" 2>&1)
        local jq_exit_code=$?
        
        if [[ $jq_exit_code -ne 0 ]]; then
            log "‚ùå JQ filter failed (exit code: $jq_exit_code)"
            log "‚ùå JQ error: $versions"
            log "‚ùå Query was: $versions_query"
            versions=""
        else
            log "‚úÖ JQ filter applied successfully"
        fi
            
        # Count non-empty lines safely
        local staging_count=0
        if [[ -n "$versions" && "$versions" != "" ]]; then
            # Remove any trailing whitespace and count non-empty lines
            local cleaned_versions
            cleaned_versions=$(echo "$versions" | sed '/^[[:space:]]*$/d')
            if [[ -n "$cleaned_versions" ]]; then
                staging_count=$(echo "$cleaned_versions" | grep -c . 2>/dev/null || echo "0")
            fi
        fi
        
        log "üîç Staging versions after filtering: $staging_count versions"
        if [[ "$staging_count" -gt 0 ]]; then
            log "üîç Version IDs to delete: $(echo "$versions" | tr '\n' ' ')"
        fi
        
        if [[ "$staging_count" -eq 0 ]]; then
            log "‚ÑπÔ∏è No staging versions to clean up for $package"
            continue
        fi
        
        local package_deleted=0
        local package_failed=0
        log "üóëÔ∏è Attempting to delete $staging_count staging versions..."
        
        # Temporarily disable ERR trap for deletion loop
        trap - ERR
        
        while IFS= read -r version_id; do
            if delete_docker_version "$endpoint" "$version_id" "$package"; then
                ((package_deleted++))
                ((total_deleted++))
            else
                ((package_failed++))
                ((total_failed++))
                log "‚ö†Ô∏è Continuing with remaining versions despite this failure"
            fi
        done <<< "$versions"
        
        # Re-enable ERR trap after deletion loop
        trap 'log "‚ùå Error occurred at line $LINENO in function ${FUNCNAME[1]:-main}"; log "‚ùå Last command: $BASH_COMMAND"; log "‚ùå Exit code: $?"' ERR
        
        log "üìä $package: deleted $package_deleted staging versions, failed $package_failed deletions"
    done
    
    if [[ $total_failed -gt 0 ]]; then
        log "üê≥ Docker staging cleanup complete with issues: $total_deleted deleted, $total_failed failed"
        log "‚ö†Ô∏è Some deletions failed but script continued successfully"
    else
        log "üê≥ Docker staging cleanup complete: $total_deleted total versions deleted"
    fi
}

# Function to safely delete an npm version with error recovery
delete_npm_version() {
    local endpoint="$1"
    local version_id="$2"
    
    if [[ -z "$version_id" || "$version_id" == "null" ]]; then
        log "‚ö†Ô∏è Skipping invalid npm version ID: '$version_id'"
        return 1
    fi
    
    # First, check if this is the last version to avoid the error
    local total_versions
    total_versions=$(gh api "${endpoint}/versions" --jq 'length' 2>/dev/null || echo "unknown")
    
    if [[ "$total_versions" == "1" ]]; then
        log "üîç Detected last npm version - will delete entire package instead of individual version"
        log "üîÑ GitHub API restriction: Cannot delete last version, must delete package"
        
        # Extract package path from endpoint for package deletion
        local package_path
        if [[ "$endpoint" =~ (/user/packages/npm/[^/]+)$ ]]; then
            package_path="${BASH_REMATCH[1]}"
            log "üîç Detected npm package path: $package_path"
            
            # Attempt to delete the entire npm package
            log "üóëÔ∏è Attempting to delete entire npm package"
            local package_delete_result
            local package_delete_exit_code
            
            set +e
            package_delete_result=$(gh api --method DELETE "$package_path" 2>&1)
            package_delete_exit_code=$?
            set -e
            
            if [[ $package_delete_exit_code -eq 0 ]]; then
                log "‚úÖ Successfully deleted entire npm package"
                log "‚úÖ npm package delete response: $package_delete_result"
                return 0
            else
                log "‚ùå Failed to delete entire npm package"
                log "‚ùå npm package delete exit code: $package_delete_exit_code"
                log "‚ùå npm package delete error: $package_delete_result"
                return 1
            fi
        else
            log "‚ùå Could not extract npm package information from endpoint: $endpoint"
            return 1
        fi
    fi
    
    log "üîç Attempting to delete npm version ID: $version_id"
    log "üîç DELETE endpoint: ${endpoint}/versions/$version_id"
    log "üîç Total versions in package: $total_versions"
    
    # Temporarily disable error exit for this operation
    set +e
    local delete_result
    local delete_exit_code
    
    delete_result=$(gh api --method DELETE "${endpoint}/versions/$version_id" 2>&1)
    delete_exit_code=$?
    
    # Re-enable error exit
    set -e
    
    if [[ $delete_exit_code -eq 0 ]]; then
        log "‚úÖ Successfully deleted npm version: $version_id"
        return 0
    else
        log "‚ùå Failed to delete npm version: $version_id"
        log "‚ùå Exit code: $delete_exit_code"
        log "‚ùå Error response: $delete_result"
        
        # Handle 400 errors with fallback to package deletion
        if [[ "$delete_result" =~ "400" ]]; then
            log "‚ùå Error type: Bad request (400) - may be last version or other constraint"
            # Fallback: attempt package deletion if version count detection failed
            if [[ "$total_versions" == "unknown" ]]; then
                log "üîÑ Attempting package deletion as fallback for 400 error"
                local package_path
                if [[ "$endpoint" =~ (/user/packages/npm/[^/]+)$ ]]; then
                    package_path="${BASH_REMATCH[1]}"
                    
                    set +e
                    local fallback_result
                    fallback_result=$(gh api --method DELETE "$package_path" 2>&1)
                    local fallback_exit_code=$?
                    set -e
                    
                    if [[ $fallback_exit_code -eq 0 ]]; then
                        log "‚úÖ Fallback npm package deletion succeeded"
                        return 0
                    else
                        log "‚ùå Fallback npm package deletion failed: $fallback_result"
                    fi
                fi
            fi
        fi
        
        return 1
    fi
}

# Function to clean up staging npm packages
cleanup_staging_npm() {
    log "üì¶ Cleaning up staging npm packages..."
    
    local scope="$NPM_SCOPE_CLEAN"
    local base_package="$NPM_STAGING_PACKAGE_NAME"
    local scoped_package="${scope}%2F${base_package}"  # URL-encoded @scope/package
    local total_deleted=0
    local total_failed=0
    
    # Try to find the npm package using different naming patterns
    # Based on testing, the working pattern is just the base package name without URL encoding the scope
    local package_patterns=(
        "$base_package"          # Base package name (verified working in testing)
        "$scoped_package"        # URL-encoded scoped package  
        "${scope}/${base_package}"  # Scoped package with slash
    )
    
    local endpoint
    for pattern in "${package_patterns[@]}"; do
        log "üîç Trying npm package pattern: $pattern"
        if endpoint=$(find_package_endpoint "npm" "$pattern" 2>/dev/null); then
            log "üìç Found staging npm package: $pattern at $endpoint"
            break
        else
            log "   npm package pattern not found: $pattern"
        fi
    done
    
    if [[ -z "$endpoint" ]]; then
        log "‚ÑπÔ∏è No staging npm packages found"
        return 0
    fi
        
    # Debug: First show basic info about npm versions
    local version_count
    version_count=$(gh api "${endpoint}/versions" --jq 'length' 2>/dev/null || echo "0")
    log "üîç Total npm versions found: $version_count"
    
    if [[ "$version_count" -gt 0 ]]; then
        log "üîç Sample npm version details:"
        gh api "${endpoint}/versions" --jq '.[:3] | .[] | "  - ID: \(.id), Name: \(.name), Created: \(.created_at)"' 2>/dev/null || log "  (Failed to get details)"
    fi
    
    # Get versions based on workflow outcome and cleanup context - filter staging versions (contain -pr.)
    local versions_query
    local strategy_description
    
    # Build the filter based on cleanup context
    local name_filter
    if [[ -n "$CLEANUP_PR_NUMBER" && "$CLEANUP_PR_NUMBER" != "MAIN_BRANCH" ]]; then
        # Target specific PR number: e.g. -pr.42.123
        name_filter='(.name | test("-pr\\.'$CLEANUP_PR_NUMBER'\\.\\d+$"))'
        strategy_description="TARGET PR #$CLEANUP_PR_NUMBER npm packages only"
        log "üéØ Targeting specific PR #$CLEANUP_PR_NUMBER npm packages"
    else
        # Fallback to broader pattern - includes staging suffix AND main branch versions  
        # Main branch publishes to GitHub Packages with production version numbers (staging context)
        # This targets: 1) PR versions (-pr.) 2) Staging suffix (-staging) 3) Any version (main branch to GitHub Packages)
        name_filter='(.name | test("-pr\\.") or test("-staging$") or true)'
        strategy_description="TARGET ALL staging npm packages (includes main branch versions to GitHub Packages)"
        log "‚ö†Ô∏è Using broad npm staging pattern - includes main branch versions published to GitHub Packages"
    fi
    
    if [[ "$WORKFLOW_OUTCOME" == "success" ]]; then
        # Delete ALL matching staging versions on success
        versions_query='.[] | select('$name_filter') | .id'
        log "  Strategy: DELETE ALL $strategy_description (workflow succeeded)"
    else
        # Keep last 5 matching staging versions on failure
        versions_query='[.[] | select('$name_filter')] | sort_by(.created_at) | reverse | .[5:] | .[].id'
        log "  Strategy: Keep last 5 of $strategy_description (workflow failed)"
    fi
    
    local versions
    versions=$(gh api \
        --paginate \
        "${endpoint}/versions" \
        --jq "$versions_query" \
        2>/dev/null || echo "")
        
    # Count non-empty lines
    local staging_count=0
    if [[ -n "$versions" ]]; then
        staging_count=$(echo "$versions" | grep -c . || echo "0")
    fi
    
    log "üîç Staging npm versions after filtering: $staging_count versions"
    if [[ "$staging_count" -eq 0 ]]; then
        log "‚ÑπÔ∏è No staging npm versions to clean up"
        return 0
    fi
    
    # Temporarily disable ERR trap for deletion loop
    trap - ERR
    
    while IFS= read -r version_id; do
        if delete_npm_version "$endpoint" "$version_id"; then
            ((total_deleted++))
        else
            ((total_failed++))
            log "‚ö†Ô∏è Continuing with remaining versions despite this failure"
        fi
    done <<< "$versions"
    
    # Re-enable ERR trap after deletion loop
    trap 'log "‚ùå Error occurred at line $LINENO in function ${FUNCNAME[1]:-main}"; log "‚ùå Last command: $BASH_COMMAND"; log "‚ùå Exit code: $?"' ERR
    
    if [[ $total_failed -gt 0 ]]; then
        log "üì¶ npm staging cleanup complete with issues: $total_deleted deleted, $total_failed failed"
    else
        log "üì¶ npm staging cleanup complete: $total_deleted versions deleted"
    fi
}

# Function to safely delete a Maven version with error recovery
delete_maven_version() {
    local endpoint="$1"
    local version_id="$2"
    
    if [[ -z "$version_id" || "$version_id" == "null" ]]; then
        log "‚ö†Ô∏è Skipping invalid Maven version ID: '$version_id'"
        return 1
    fi
    
    # First, check if this is the last version to avoid the error
    local total_versions
    total_versions=$(gh api "${endpoint}/versions" --jq 'length' 2>/dev/null || echo "unknown")
    
    if [[ "$total_versions" == "1" ]]; then
        log "üîç Detected last Maven version - will delete entire package instead of individual version"
        log "üîÑ GitHub API restriction: Cannot delete last version, must delete package"
        
        # Extract package path from endpoint for package deletion
        local package_path
        if [[ "$endpoint" =~ (/user/packages/maven/[^/]+)$ ]]; then
            package_path="${BASH_REMATCH[1]}"
            log "üîç Detected Maven package path: $package_path"
            
            # Attempt to delete the entire Maven package
            log "üóëÔ∏è Attempting to delete entire Maven package"
            local package_delete_result
            local package_delete_exit_code
            
            set +e
            package_delete_result=$(gh api --method DELETE "$package_path" 2>&1)
            package_delete_exit_code=$?
            set -e
            
            if [[ $package_delete_exit_code -eq 0 ]]; then
                log "‚úÖ Successfully deleted entire Maven package"
                log "‚úÖ Maven package delete response: $package_delete_result"
                return 0
            else
                log "‚ùå Failed to delete entire Maven package"
                log "‚ùå Maven package delete exit code: $package_delete_exit_code"
                log "‚ùå Maven package delete error: $package_delete_result"
                return 1
            fi
        else
            log "‚ùå Could not extract Maven package information from endpoint: $endpoint"
            return 1
        fi
    fi
    
    log "üîç Attempting to delete Maven version ID: $version_id"
    log "üîç DELETE endpoint: ${endpoint}/versions/$version_id"
    log "üîç Total versions in package: $total_versions"
    
    # Temporarily disable error exit for this operation
    set +e
    local delete_result
    local delete_exit_code
    
    delete_result=$(gh api --method DELETE "${endpoint}/versions/$version_id" 2>&1)
    delete_exit_code=$?
    
    # Re-enable error exit
    set -e
    
    if [[ $delete_exit_code -eq 0 ]]; then
        log "‚úÖ Successfully deleted Maven version: $version_id"
        return 0
    else
        log "‚ùå Failed to delete Maven version: $version_id"
        log "‚ùå Exit code: $delete_exit_code"
        log "‚ùå Error response: $delete_result"
        
        # Handle 400 errors with fallback to package deletion
        if [[ "$delete_result" =~ "400" ]]; then
            log "‚ùå Error type: Bad request (400) - may be last version or other constraint"
            # Fallback: attempt package deletion if version count detection failed
            if [[ "$total_versions" == "unknown" ]]; then
                log "üîÑ Attempting package deletion as fallback for 400 error"
                local package_path
                if [[ "$endpoint" =~ (/user/packages/maven/[^/]+)$ ]]; then
                    package_path="${BASH_REMATCH[1]}"
                    
                    set +e
                    local fallback_result
                    fallback_result=$(gh api --method DELETE "$package_path" 2>&1)
                    local fallback_exit_code=$?
                    set -e
                    
                    if [[ $fallback_exit_code -eq 0 ]]; then
                        log "‚úÖ Fallback Maven package deletion succeeded"
                        return 0
                    else
                        log "‚ùå Fallback Maven package deletion failed: $fallback_result"
                    fi
                fi
            fi
        fi
        
        return 1
    fi
}

# Function to clean up staging Maven packages
cleanup_staging_maven() {
    log "üèóÔ∏è Cleaning up staging Maven packages..."
    
    local package_name="$ANDROID_STAGING_PACKAGE"
    local total_deleted=0
    local total_failed=0
    
    # Find the Maven package using dynamic endpoint detection
    # Based on testing, the full package name format works
    local endpoint
    log "üîç Searching for Maven package: $package_name"
    if ! endpoint=$(find_package_endpoint "maven" "$package_name" 2>/dev/null); then
        log "‚ÑπÔ∏è No staging Maven packages found with name: $package_name"
        return 0
    else
        log "üìç Found staging Maven package: $package_name at $endpoint"
    fi
        
    # Debug: First show basic info about Maven versions
    local version_count
    version_count=$(gh api "${endpoint}/versions" --jq 'length' 2>/dev/null || echo "0")
    log "üîç Total Maven versions found: $version_count"
    
    if [[ "$version_count" -gt 0 ]]; then
        log "üîç Sample Maven version details:"
        gh api "${endpoint}/versions" --jq '.[:3] | .[] | "  - ID: \(.id), Name: \(.name), Created: \(.created_at)"' 2>/dev/null || log "  (Failed to get details)"
    fi
    
    # Get versions based on workflow outcome and cleanup context - filter staging versions (contain -pr.)
    local versions_query
    local strategy_description
    
    # Build the filter based on cleanup context
    local name_filter
    if [[ -n "$CLEANUP_PR_NUMBER" && "$CLEANUP_PR_NUMBER" != "MAIN_BRANCH" ]]; then
        # Target specific PR number: e.g. -pr.42.123
        name_filter='(.name | test("-pr\\.'$CLEANUP_PR_NUMBER'\\.\\d+$"))'
        strategy_description="TARGET PR #$CLEANUP_PR_NUMBER Maven packages only"
        log "üéØ Targeting specific PR #$CLEANUP_PR_NUMBER Maven packages"
    else
        # Fallback to broader pattern - includes staging suffix AND main branch versions
        # Main branch publishes to GitHub Packages with production version numbers (staging context)
        # This targets: 1) PR versions (-pr.) 2) Staging suffix (-staging) 3) Any version (main branch to GitHub Packages)
        name_filter='(.name | test("-pr\\.") or test("-staging$") or true)'
        strategy_description="TARGET ALL staging Maven packages (includes main branch versions to GitHub Packages)"
        log "‚ö†Ô∏è Using broad Maven staging pattern - includes main branch versions published to GitHub Packages"
    fi
    
    if [[ "$WORKFLOW_OUTCOME" == "success" ]]; then
        # Delete ALL matching staging versions on success
        versions_query='.[] | select('$name_filter') | .id'
        log "  Strategy: DELETE ALL $strategy_description (workflow succeeded)"
    else
        # Keep last 5 matching staging versions on failure
        versions_query='[.[] | select('$name_filter')] | sort_by(.created_at) | reverse | .[5:] | .[].id'
        log "  Strategy: Keep last 5 of $strategy_description (workflow failed)"
    fi
    
    local versions
    versions=$(gh api \
        --paginate \
        "${endpoint}/versions" \
        --jq "$versions_query" \
        2>/dev/null || echo "")
        
    # Count non-empty lines
    local staging_count=0
    if [[ -n "$versions" ]]; then
        staging_count=$(echo "$versions" | grep -c . || echo "0")
    fi
    
    log "üîç Staging Maven versions after filtering: $staging_count versions"
    if [[ "$staging_count" -eq 0 ]]; then
        log "‚ÑπÔ∏è No staging Maven versions to clean up"
        return 0
    fi
    
    # Temporarily disable ERR trap for deletion loop
    trap - ERR
    
    while IFS= read -r version_id; do
        if delete_maven_version "$endpoint" "$version_id"; then
            ((total_deleted++))
        else
            ((total_failed++))
            log "‚ö†Ô∏è Continuing with remaining versions despite this failure"
        fi
    done <<< "$versions"
    
    # Re-enable ERR trap after deletion loop
    trap 'log "‚ùå Error occurred at line $LINENO in function ${FUNCNAME[1]:-main}"; log "‚ùå Last command: $BASH_COMMAND"; log "‚ùå Exit code: $?"' ERR
    
    if [[ $total_failed -gt 0 ]]; then
        log "üèóÔ∏è Maven staging cleanup complete with issues: $total_deleted deleted, $total_failed failed"
    else
        log "üèóÔ∏è Maven staging cleanup complete: $total_deleted versions deleted"
    fi
}

# Main cleanup function
perform_staging_cleanup() {
    log "üßπ Starting GitHub Packages staging cleanup"
    log "üìã Cleanup scope: ONLY GitHub Packages staging artifacts"
    log "üéØ Workflow outcome: $WORKFLOW_OUTCOME"
    log "üè¢ Repository owner: $REPOSITORY_OWNER"
    log "üéØ Cleanup context: $CLEANUP_CONTEXT"
    if [[ -n "$CLEANUP_PR_NUMBER" && "$CLEANUP_PR_NUMBER" != "MAIN_BRANCH" ]]; then
        log "üîç Targeting PR: #$CLEANUP_PR_NUMBER"
        log "üìã Package patterns:"
        log "  - Docker tags: pr-${CLEANUP_PR_NUMBER}, sha256-*-pr-${CLEANUP_PR_NUMBER}"
        log "  - npm/Maven versions: *-pr.${CLEANUP_PR_NUMBER}.*"
    elif [[ "$CLEANUP_PR_NUMBER" == "MAIN_BRANCH" ]]; then
        log "üîç Targeting: MAIN BRANCH (all staging packages)"
        log "üìã Package patterns:"
        log "  - Docker tags: pr-*, latest, sha256-*-{pr|main|manual|branch}-*, *-staging"
        log "  - npm/Maven versions: *-pr.*, *-staging, main branch versions"
    else
        log "‚ö†Ô∏è Using broad staging patterns (fallback)"
        log "üìã Package patterns:"
        log "  - Docker tags: pr-*, latest, sha256-*-{pr|main|manual|branch}-*, *-staging"
        log "  - npm/Maven versions: *-pr.*, *-staging, main branch versions"
    fi
    log ""
    
    case "$WORKFLOW_OUTCOME" in
        "success")
            log "‚úÖ Workflow succeeded - performing COMPLETE staging cleanup"
            log "üóëÔ∏è Strategy: Delete ALL staging packages (validation complete)"
            ;;
        "failure")
            log "‚ùå Workflow failed - performing CONSERVATIVE staging cleanup"
            log "üîç Strategy: Keep last 5 versions for debugging"
            ;;
    esac
    
    log ""
    
    # Track overall cleanup statistics
    local overall_success=true
    local cleanup_errors=0
    
    # Perform cleanup for each package type with error tracking
    log "üê≥ Phase 1/3: Docker image cleanup"
    if ! cleanup_staging_docker; then
        overall_success=false
        ((cleanup_errors++))
        log "‚ö†Ô∏è Docker cleanup encountered issues but script continues"
    fi
    log ""
    
    log "üì¶ Phase 2/3: npm package cleanup"
    if ! cleanup_staging_npm; then
        overall_success=false
        ((cleanup_errors++))
        log "‚ö†Ô∏è npm cleanup encountered issues but script continues"
    fi
    log ""
    
    log "üèóÔ∏è Phase 3/3: Maven package cleanup"
    if ! cleanup_staging_maven; then
        overall_success=false
        ((cleanup_errors++))
        log "‚ö†Ô∏è Maven cleanup encountered issues but script continues"
    fi
    
    log ""
    if [[ "$overall_success" == "true" ]]; then
        log "üéâ GitHub Packages staging cleanup completed successfully"
        
        # Report Docker preservation status for main branch builds
        if [[ "${DOCKER_CLEANUP_STRATEGY:-}" == "preserve" ]]; then
            log "üö® DOCKER IMAGES PRESERVED: Main branch build detected"
            log "üì¶ Docker images left in GHCR for DockerHub publishing workflow"
            log "üîÑ Post-processing workflow will complete final cleanup"
        else
            log "üóëÔ∏è All staging packages cleaned up (standard cleanup)"
        fi
    else
        log "‚ö†Ô∏è GitHub Packages staging cleanup completed with $cleanup_errors phase(s) having issues"
        log "üìã Script completed successfully despite individual deletion failures"
        
        # Report Docker preservation status even with some failures
        if [[ "${DOCKER_CLEANUP_STRATEGY:-}" == "preserve" ]]; then
            log "üö® DOCKER IMAGES PRESERVED: Main branch build (despite other cleanup issues)"
        fi
    fi
}

# Check for emergency override in commit message
check_preserve_override() {
    # Check if latest commit message contains [preserve] keyword
    if git log -1 --pretty=%s 2>/dev/null | grep -i '\[preserve\]' >/dev/null; then
        log "üö® EMERGENCY OVERRIDE: [preserve] keyword found in commit message"
        log "‚ö†Ô∏è  Skipping all staging cleanup for manual investigation"
        exit 0
    fi
}

# Main execution
main() {
    log "üöÄ GitHub Packages Staging Cleanup Script Starting"
    
    # Production cleanup mode
    # Check for emergency override first
    check_preserve_override
    
    # Load central configuration
    load_central_config
    
    # Validate inputs and GitHub CLI
    validate_inputs
    validate_github_cli
    
    # Determine cleanup scope based on context
    determine_cleanup_scope
    
    # Perform staging cleanup
    perform_staging_cleanup
    
    log "‚úÖ Staging cleanup script completed successfully"
    log "üìã Summary: Script uses enhanced error recovery and continues despite individual failures"
    log "üîß If you see deletion failures above, check GitHub token permissions (packages:write required)"
}

# Enhanced error trapping for better debugging
# Note: ERR trap disabled during deletion loops to allow graceful error handling
trap 'log "‚ùå Error occurred at line $LINENO in function ${FUNCNAME[1]:-main}"; log "‚ùå Last command: $BASH_COMMAND"; log "‚ùå Exit code: $?"' ERR

# Run main function
main