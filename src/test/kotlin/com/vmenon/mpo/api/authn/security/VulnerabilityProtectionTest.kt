package com.vmenon.mpo.api.authn.security

import com.fasterxml.jackson.databind.node.ObjectNode
import com.vmenon.mpo.api.authn.di.storageModule
import com.vmenon.mpo.api.authn.module
import com.vmenon.mpo.api.authn.testStorageModule
import com.vmenon.mpo.api.authn.test_utils.BaseIntegrationTest
import com.vmenon.mpo.api.authn.test_utils.yubico.TestAuthenticator
import com.vmenon.mpo.api.authn.utils.JacksonUtils
import com.yubico.webauthn.data.ByteArray
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.bodyAsText
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.HttpStatusCode
import io.ktor.http.contentType
import io.ktor.server.testing.testApplication
import kotlin.test.assertEquals
import kotlin.test.assertNotEquals
import kotlin.test.assertTrue
import kotlin.time.measureTime
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import org.koin.core.context.stopKoin

/**
 * Vulnerability protection tests for WebAuthn implementation
 *
 * Tests to verify protection against known vulnerabilities:
 * - PoisonSeed attacks (cross-origin authentication abuse)
 * - Username enumeration (CVE-2024-39912)
 * - Replay attacks
 * - Credential tampering
 * - Origin confusion attacks
 *
 * These tests validate that the Yubico java-webauthn-server library
 * and KTor application are properly configured to prevent security issues.
 */
class VulnerabilityProtectionTest : BaseIntegrationTest() {

    private val objectMapper = JacksonUtils.objectMapper

    @BeforeEach
    fun setup() {
        stopKoin()
    }

    @AfterEach
    fun teardown() {
        stopKoin()
    }

    @Test
    @DisplayName("Should reject authentication attempts with invalid origins")
    fun `test protection against cross-origin poisonseed attacks`() = testApplication {
        application {
            module(storageModule)
        }

        val username = "poisonseed_test_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Register a user first
        val startRegResponse = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username", "displayName": "$username"}""")
        }

        if (startRegResponse.status == HttpStatusCode.OK) {
            val startData = objectMapper.readTree(startRegResponse.bodyAsText())
            val requestId = startData.get("requestId")?.asText()
            val challenge = startData.get("publicKeyCredentialCreationOptions")
                ?.get("publicKey")?.get("challenge")?.asText()

            if (requestId != null && challenge != null) {
                val credential = TestAuthenticator.createUnattestedCredentialForRegistration(
                    ByteArray.fromBase64Url(challenge),
                    keyPair
                )

                client.post("/register/complete") {
                    contentType(ContentType.Application.Json)
                    setBody(
                        objectMapper.writeValueAsString(
                            mapOf(
                                "requestId" to requestId,
                                "credential" to objectMapper.writeValueAsString(credential.first)
                            )
                        )
                    )
                }
            }

            // Now attempt authentication with malicious origin
            val maliciousOrigin = "https://evil-phishing-site.com"

            val authStartResponse = client.post("/authenticate/start") {
                contentType(ContentType.Application.Json)
                header(HttpHeaders.Origin, maliciousOrigin)
                setBody("""{"username": "$username"}""")
            }

            if (authStartResponse.status == HttpStatusCode.OK) {
                val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                val authChallenge = authStartData.get("publicKeyCredentialRequestOptions")
                    ?.get("publicKey")?.get("challenge")?.asText()

                if (authChallenge != null) {
                    // Create credential with malicious origin in clientDataJSON
                    val maliciousClientData =
                        """{"type":"webauthn.get","challenge":"$authChallenge","origin":"$maliciousOrigin"}"""
                    val tamperedCredential =
                        createTamperedCredentialWithOrigin(authChallenge, keyPair, maliciousClientData)

                    val authCompleteResponse = client.post("/authenticate/complete") {
                        contentType(ContentType.Application.Json)
                        setBody(
                            objectMapper.writeValueAsString(
                                mapOf(
                                    "requestId" to authStartData.get("requestId").asText(),
                                    "credential" to tamperedCredential
                                )
                            )
                        )
                    }

                    // The Yubico library should reject this due to origin mismatch
                    assertNotEquals(
                        HttpStatusCode.OK,
                        authCompleteResponse.status,
                        "Authentication with malicious origin should be rejected"
                    )

                    val responseBody = authCompleteResponse.bodyAsText()
                    assertTrue(
                        responseBody.contains("error") || authCompleteResponse.status.value >= 400,
                        "Response should indicate authentication failure: $responseBody"
                    )
                }
            }
        }
    }

    @Test
    @DisplayName("Should provide consistent responses for existing vs non-existent users")
    fun `test protection against username enumeration via response differences`() = testApplication {
        application {
            module(testStorageModule)
        }

        val existingUser = "existing_${System.currentTimeMillis()}"
        val nonExistentUser = "nonexistent_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Register the existing user
        val startRegResponse = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$existingUser", "displayName": "$existingUser"}""")
        }

        if (startRegResponse.status == HttpStatusCode.OK) {
            val startData = objectMapper.readTree(startRegResponse.bodyAsText())
            val requestId = startData.get("requestId")?.asText()
            val challenge = startData.get("publicKeyCredentialCreationOptions")
                ?.get("publicKey")?.get("challenge")?.asText()

            val credential = TestAuthenticator.createUnattestedCredentialForRegistration(
                ByteArray.fromBase64Url(challenge!!),
                keyPair
            )

            client.post("/register/complete") {
                contentType(ContentType.Application.Json)
                setBody(
                    objectMapper.writeValueAsString(
                        mapOf(
                            "requestId" to requestId,
                            "credential" to objectMapper.writeValueAsString(credential.first)
                        )
                    )
                )
            }
        }

        // Test authentication start for existing user
        val existingUserResponse = client.post("/authenticate/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$existingUser"}""")
        }

        // Test authentication start for non-existent user
        val nonExistentUserResponse = client.post("/authenticate/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$nonExistentUser"}""")
        }

        // Analyze responses for enumeration vulnerabilities
        val existingUserData = objectMapper.readTree(existingUserResponse.bodyAsText())
        val nonExistentUserData = objectMapper.readTree(nonExistentUserResponse.bodyAsText())

        // Check if responses are too different (indicating enumeration vulnerability)
        val statusesMatch = existingUserResponse.status == nonExistentUserResponse.status
        val structuresMatch = existingUserData.has("requestId") == nonExistentUserData.has("requestId")

        // Print results for analysis
        println("Existing user status: ${existingUserResponse.status}")
        println("Non-existent user status: ${nonExistentUserResponse.status}")
        println("Existing user has requestId: ${existingUserData.has("requestId")}")
        println("Non-existent user has requestId: ${nonExistentUserData.has("requestId")}")

        // The Yubico library should handle this properly - this test documents current behavior
        assertTrue(
            statusesMatch || (existingUserResponse.status == HttpStatusCode.OK &&
                    nonExistentUserResponse.status == HttpStatusCode.OK),
            "Responses should not reveal user existence differences that enable enumeration"
        )
    }

    @Test
    @DisplayName("Should have consistent response timing to prevent timing attacks")
    fun `test consistent timing prevents username enumeration`() = testApplication {
        application {
            module(testStorageModule)
        }

        val existingUser = "timing_existing_${System.currentTimeMillis()}"
        val nonExistentUser = "timing_nonexistent_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Register the existing user
        val startRegResponse = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$existingUser", "displayName": "$existingUser"}""")
        }

        if (startRegResponse.status == HttpStatusCode.OK) {
            val startData = objectMapper.readTree(startRegResponse.bodyAsText())
            val requestId = startData.get("requestId")?.asText()
            val challenge = startData.get("publicKeyCredentialCreationOptions")
                ?.get("publicKey")?.get("challenge")?.asText()

            val credential = TestAuthenticator.createUnattestedCredentialForRegistration(
                ByteArray.fromBase64Url(challenge!!),
                keyPair
            )

            client.post("/register/complete") {
                contentType(ContentType.Application.Json)
                setBody(
                    objectMapper.writeValueAsString(
                        mapOf(
                            "requestId" to requestId,
                            "credential" to objectMapper.writeValueAsString(credential.first)
                        )
                    )
                )
            }
        }

        // Measure timing for existing user (multiple samples for accuracy)
        val existingUserTimes = mutableListOf<Long>()
        repeat(3) {
            val time = measureTime {
                client.post("/authenticate/start") {
                    contentType(ContentType.Application.Json)
                    setBody("""{"username": "$existingUser"}""")
                }
            }.inWholeMilliseconds
            existingUserTimes.add(time)
        }

        // Measure timing for non-existent user
        val nonExistentUserTimes = mutableListOf<Long>()
        repeat(3) {
            val time = measureTime {
                client.post("/authenticate/start") {
                    contentType(ContentType.Application.Json)
                    setBody("""{"username": "$nonExistentUser"}""")
                }
            }.inWholeMilliseconds
            nonExistentUserTimes.add(time)
        }

        val avgExistingTime = existingUserTimes.average()
        val avgNonExistentTime = nonExistentUserTimes.average()
        val timingDifference = kotlin.math.abs(avgExistingTime - avgNonExistentTime)

        println("Average existing user time: ${avgExistingTime}ms")
        println("Average non-existent user time: ${avgNonExistentTime}ms")
        println("Timing difference: ${timingDifference}ms")

        // Allow for reasonable variance in response times
        assertTrue(
            timingDifference < 200, // Less than 200ms difference (generous for test environment)
            "Timing difference of ${timingDifference}ms could enable username enumeration"
        )
    }

    @Test
    @DisplayName("Should prevent replay of authentication responses")
    fun `test protection against authentication replay attacks`() = testApplication {
        application {
            module(testStorageModule)
        }

        val username = "replay_test_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Register user first
        val startRegResponse = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username", "displayName": "$username"}""")
        }

        if (startRegResponse.status == HttpStatusCode.OK) {
            val startData = objectMapper.readTree(startRegResponse.bodyAsText())
            val requestId = startData.get("requestId")?.asText()
            val challenge = startData.get("publicKeyCredentialCreationOptions")
                ?.get("publicKey")?.get("challenge")?.asText()

            val credential = TestAuthenticator.createUnattestedCredentialForRegistration(
                ByteArray.fromBase64Url(challenge!!),
                keyPair
            )

            client.post("/register/complete") {
                contentType(ContentType.Application.Json)
                setBody(
                    objectMapper.writeValueAsString(
                        mapOf(
                            "requestId" to requestId,
                            "credential" to objectMapper.writeValueAsString(credential.first)
                        )
                    )
                )
            }

            // Perform first authentication
            val authStartResponse = client.post("/authenticate/start") {
                contentType(ContentType.Application.Json)
                setBody("""{"username": "$username"}""")
            }

            if (authStartResponse.status == HttpStatusCode.OK) {
                val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                val authRequestId = authStartData.get("requestId").asText()
                val authChallenge = authStartData.get("publicKeyCredentialRequestOptions")
                    ?.get("publicKey")?.get("challenge")?.asText()

                if (authChallenge != null) {
                    val authCredential = TestAuthenticator.createUnattestedCredentialForAuthentication(
                        ByteArray.fromBase64Url(authChallenge),
                        ByteArray.fromBase64Url("test-credential-id"),
                        keyPair
                    )

                    val completeRequestBody = objectMapper.writeValueAsString(
                        mapOf(
                            "requestId" to authRequestId,
                            "credential" to objectMapper.writeValueAsString(authCredential)
                        )
                    )

                    // First authentication
                    val firstAuthResponse = client.post("/authenticate/complete") {
                        contentType(ContentType.Application.Json)
                        setBody(completeRequestBody)
                    }

                    // Attempt to replay the same request
                    val replayResponse = client.post("/authenticate/complete") {
                        contentType(ContentType.Application.Json)
                        setBody(completeRequestBody)
                    }

                    // Replay should fail - request ID should be consumed
                    assertNotEquals(
                        HttpStatusCode.OK,
                        replayResponse.status,
                        "Replay attack should be rejected"
                    )

                    val replayResponseBody = replayResponse.bodyAsText()
                    assertTrue(
                        replayResponseBody.contains("Invalid or expired request ID") ||
                                replayResponseBody.contains("error"),
                        "Replay should be rejected with appropriate error: $replayResponseBody"
                    )
                }
            }
        }
    }

    @Test
    @DisplayName("Should ensure challenge uniqueness across authentication attempts")
    fun `test challenge uniqueness prevents replay attacks`() = testApplication {
        application {
            module(testStorageModule)
        }

        val username = "challenge_test_${System.currentTimeMillis()}"

        // Start multiple authentication sessions
        val auth1Response = client.post("/authenticate/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username"}""")
        }

        val auth2Response = client.post("/authenticate/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username"}""")
        }

        assertEquals(HttpStatusCode.OK, auth1Response.status, "First auth start should succeed")
        assertEquals(HttpStatusCode.OK, auth2Response.status, "Second auth start should succeed")

        val auth1Data = objectMapper.readTree(auth1Response.bodyAsText())
        val auth2Data = objectMapper.readTree(auth2Response.bodyAsText())

        val challenge1 =
            auth1Data.get("publicKeyCredentialRequestOptions")?.get("publicKey")?.get("challenge")?.asText()
        val challenge2 =
            auth2Data.get("publicKeyCredentialRequestOptions")?.get("publicKey")?.get("challenge")?.asText()

        // Challenges should be unique
        if (challenge1 != null && challenge2 != null) {
            assertNotEquals(
                challenge1,
                challenge2,
                "Each authentication session should have a unique challenge"
            )
        }

        // Request IDs should also be unique
        val requestId1 = auth1Data.get("requestId").asText()
        val requestId2 = auth2Data.get("requestId").asText()

        assertNotEquals(
            requestId1,
            requestId2,
            "Each authentication session should have a unique request ID"
        )
    }

    @Test
    @DisplayName("Should detect and reject tampered credentials")
    fun `test protection against credential response tampering`() = testApplication {
        application {
            module(testStorageModule)
        }

        val username = "tamper_test_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Register user first
        val startRegResponse = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username", "displayName": "$username"}""")
        }

        if (startRegResponse.status == HttpStatusCode.OK) {
            val startData = objectMapper.readTree(startRegResponse.bodyAsText())
            val requestId = startData.get("requestId")?.asText()
            val challenge = startData.get("publicKeyCredentialCreationOptions")
                ?.get("publicKey")?.get("challenge")?.asText()

            val credential = TestAuthenticator.createUnattestedCredentialForRegistration(
                ByteArray.fromBase64Url(challenge!!),
                keyPair
            )

            client.post("/register/complete") {
                contentType(ContentType.Application.Json)
                setBody(
                    objectMapper.writeValueAsString(
                        mapOf(
                            "requestId" to requestId,
                            "credential" to objectMapper.writeValueAsString(credential.first)
                        )
                    )
                )
            }

            // Start authentication
            val authStartResponse = client.post("/authenticate/start") {
                contentType(ContentType.Application.Json)
                setBody("""{"username": "$username"}""")
            }

            if (authStartResponse.status == HttpStatusCode.OK) {
                val authStartData = objectMapper.readTree(authStartResponse.bodyAsText())
                val authRequestId = authStartData.get("requestId").asText()
                val authChallenge = authStartData.get("publicKeyCredentialRequestOptions")
                    ?.get("publicKey")?.get("challenge")?.asText()

                if (authChallenge != null) {
                    // Create legitimate credential
                    val legitimateCredential = TestAuthenticator.createUnattestedCredentialForAuthentication(
                        ByteArray.fromBase64Url(authChallenge),
                        ByteArray.fromBase64Url("test-credential-id"),
                        keyPair
                    )

                    // Tamper with the credential
                    val credentialJson = objectMapper.writeValueAsString(legitimateCredential)
                    val tamperedCredential = tamperWithCredentialSignature(credentialJson)

                    // Attempt authentication with tampered credential
                    val tamperedAuthResponse = client.post("/authenticate/complete") {
                        contentType(ContentType.Application.Json)
                        setBody(
                            objectMapper.writeValueAsString(
                                mapOf(
                                    "requestId" to authRequestId,
                                    "credential" to tamperedCredential
                                )
                            )
                        )
                    }

                    // Tampered authentication should fail
                    assertNotEquals(
                        HttpStatusCode.OK,
                        tamperedAuthResponse.status,
                        "Authentication with tampered credential should be rejected"
                    )

                    val responseBody = tamperedAuthResponse.bodyAsText()
                    assertTrue(
                        responseBody.contains("error") || responseBody.contains("Authentication failed"),
                        "Response should indicate authentication failure: $responseBody"
                    )
                }
            }
        }
    }

    @Test
    @DisplayName("Should verify basic security configurations work")
    fun `test basic webauthn security configurations`() = testApplication {
        application {
            module(testStorageModule)
        }

        // Test that basic WebAuthn flows work (indicating proper configuration)
        val username = "config_test_${System.currentTimeMillis()}"
        val keyPair = TestAuthenticator.generateKeypair(algorithm = TestAuthenticator.Defaults.keyAlgorithm)

        // Test registration works
        val registrationResult = client.post("/register/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username", "displayName": "$username"}""")
        }

        assertEquals(
            HttpStatusCode.OK,
            registrationResult.status,
            "Registration should work with proper configuration"
        )

        // Test authentication start works (even for non-existent user due to enumeration protection)
        val authResult = client.post("/authenticate/start") {
            contentType(ContentType.Application.Json)
            setBody("""{"username": "$username"}""")
        }

        assertEquals(HttpStatusCode.OK, authResult.status, "Authentication start should work")

        println("✅ Basic WebAuthn security configurations are working properly")
    }
    
    // Helper methods for credential tampering

    private fun createTamperedCredentialWithOrigin(
        challenge: String,
        keyPair: java.security.KeyPair,
        maliciousClientData: String
    ): String {
        // Create a credential with tampered client data JSON
        val credential = TestAuthenticator.createUnattestedCredentialForAuthentication(
            ByteArray.fromBase64Url(challenge),
            ByteArray.fromBase64Url("test-credential-id"),
            keyPair
        )

        val credentialJson = objectMapper.writeValueAsString(credential)
        val credentialNode = objectMapper.readTree(credentialJson) as ObjectNode

        // Replace the clientDataJSON with our malicious version
        val maliciousClientDataB64 = java.util.Base64.getEncoder().encodeToString(maliciousClientData.toByteArray())
        credentialNode.put("clientDataJSON", maliciousClientDataB64)

        return objectMapper.writeValueAsString(credentialNode)
    }

    private fun tamperWithCredentialSignature(credentialJson: String): String {
        val credentialNode = objectMapper.readTree(credentialJson) as ObjectNode

        // Tamper with the signature field
        credentialNode.put("signature", "dGFtcGVyZWRfc2lnbmF0dXJl") // "tampered_signature" in base64

        return objectMapper.writeValueAsString(credentialNode)
    }
}