#!/usr/bin/env python3
"""
Unit tests for VulnerabilityCategorizor standalone module.

Tests categorization logic, fail-fast behavior, and tool mapping.
"""

import pytest
from unittest.mock import patch
import logging

from vulnerability_categorizer import VulnerabilityCategorizor


class TestVulnerabilityCategorizor:
    """Test suite for VulnerabilityCategorizor with comprehensive coverage."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.categorizer = VulnerabilityCategorizor()

    def test_initialization(self):
        """Test VulnerabilityCategorizor initialization."""
        assert self.categorizer is not None
        assert isinstance(self.categorizer.tool_category_map, dict)
        assert isinstance(self.categorizer.webauthn_patterns, list)
        assert len(self.categorizer.tool_category_map) >= 10  # Should have comprehensive tool coverage

    def test_container_security_categorization(self):
        """Test container security tool categorization."""
        # Test sarif-trivy
        vulnerability = {
            'id': 'CONTAINER-001',
            'tool': 'sarif-trivy',
            'description': 'Container running as root user',
            'file_path': 'Dockerfile'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'container_security'
        assert 0.8 <= confidence <= 1.0

        # Test trivy (base tool name)
        vulnerability['tool'] = 'trivy'
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'container_security'

    def test_infrastructure_security_categorization(self):
        """Test infrastructure security tool categorization."""
        # Test sarif-checkov
        vulnerability = {
            'id': 'INFRA-001',
            'tool': 'sarif-checkov',
            'description': 'S3 bucket allows public read access',
            'file_path': 'terraform/s3.tf'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'infrastructure_security'
        assert 0.8 <= confidence <= 1.0

        # Test gitleaks
        vulnerability['tool'] = 'gitleaks'
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'infrastructure_security'

    def test_web_security_categorization(self):
        """Test web security tool categorization."""
        vulnerability = {
            'id': 'WEB-001',
            'tool': 'zap',
            'description': 'Cross-site scripting vulnerability detected',
            'file_path': '/api/users'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'web_security'
        assert 0.7 <= confidence <= 1.0

        # Test sarif-zap
        vulnerability['tool'] = 'sarif-zap'
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'web_security'

    def test_dependency_vulnerabilities_categorization(self):
        """Test dependency vulnerability tool categorization."""
        vulnerability = {
            'id': 'DEP-001',
            'tool': 'osv-scanner',
            'description': 'Known vulnerability in express@4.16.0',
            'severity': 'HIGH'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'dependency_vulnerabilities'
        assert 0.8 <= confidence <= 1.0

    def test_webauthn_security_detection(self):
        """Test WebAuthn-specific pattern detection from semgrep."""
        # Strong WebAuthn indication (multiple patterns)
        vulnerability = {
            'id': 'WEBAUTHN-001',
            'tool': 'semgrep',
            'description': 'WebAuthn credential validation bypass in authenticator challenge',
            'file_path': 'src/webauthn/attestation.ts',
            'metadata': {'webauthn': True, 'fido': True}
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'webauthn_security'
        assert 0.8 <= confidence <= 1.0

        # Multiple WebAuthn patterns (credential + passkey = 2 patterns)
        vulnerability_multiple = {
            'id': 'WEBAUTHN-002',
            'tool': 'semgrep',
            'description': 'Credential handling issue in passkey implementation',
            'file_path': 'src/auth.js'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability_multiple)
        assert category == 'webauthn_security'
        assert confidence == 0.9  # 0.8 + (2 * 0.05)

    def test_code_vulnerabilities_fallback(self):
        """Test code vulnerabilities as fallback for semgrep without WebAuthn patterns."""
        vulnerability = {
            'id': 'CODE-001',
            'tool': 'semgrep',
            'description': 'SQL injection vulnerability in user query',
            'file_path': 'src/database.js'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'code_vulnerabilities'
        assert 0.7 <= confidence <= 1.0

    def test_mobile_security_categorization(self):
        """Test mobile security tool categorization."""
        vulnerability = {
            'id': 'MOBILE-001',
            'tool': 'mobsf',
            'description': 'Android app allows clear text traffic',
            'file_path': 'AndroidManifest.xml'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'mobile_security'

    def test_confidence_calculation_factors(self):
        """Test confidence score calculation based on various factors."""
        # High confidence tool with rich description and high severity
        vulnerability = {
            'id': 'TEST-001',
            'tool': 'sarif-trivy',
            'description': 'This is a very detailed description of a container security vulnerability that affects the base image and should be addressed immediately due to its security implications.',
            'severity': 'CRITICAL'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert confidence >= 0.95  # High confidence due to tool + description + severity

        # Lower confidence with minimal information
        vulnerability_minimal = {
            'id': 'TEST-002',
            'tool': 'zap',
            'description': 'Issue found'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability_minimal)
        assert confidence <= 0.85  # Lower confidence due to minimal info

    def test_fail_fast_missing_tool(self):
        """Test fail-fast behavior when vulnerability is missing tool field."""
        vulnerability = {
            'id': 'FAIL-001',
            'description': 'Vulnerability without tool field'
        }
        with pytest.raises(ValueError) as exc_info:
            self.categorizer.categorize_vulnerability(vulnerability)

        assert "missing 'tool' field" in str(exc_info.value)
        assert "FAIL-001" in str(exc_info.value)

    def test_fail_fast_empty_tool(self):
        """Test fail-fast behavior when tool field is empty."""
        vulnerability = {
            'id': 'FAIL-002',
            'tool': '',
            'description': 'Vulnerability with empty tool field'
        }
        with pytest.raises(ValueError) as exc_info:
            self.categorizer.categorize_vulnerability(vulnerability)

        assert "missing 'tool' field" in str(exc_info.value)

    def test_fail_fast_unknown_tool(self):
        """Test fail-fast behavior for unknown security tools."""
        vulnerability = {
            'id': 'FAIL-003',
            'tool': 'unknown-scanner',
            'description': 'Vulnerability from unsupported tool'
        }
        with pytest.raises(ValueError) as exc_info:
            self.categorizer.categorize_vulnerability(vulnerability)

        error_message = str(exc_info.value)
        assert "Unknown security tool 'unknown-scanner'" in error_message
        assert "FAIL-003" in error_message
        assert "pipeline must stop" in error_message
        assert "Supported tools:" in error_message

    def test_tool_category_mapping_completeness(self):
        """Test that tool category mapping covers all expected security domains."""
        expected_categories = {
            'container_security',
            'infrastructure_security',
            'web_security',
            'dependency_vulnerabilities',
            'code_vulnerabilities',
            'mobile_security'
        }

        mapped_categories = set(self.categorizer.tool_category_map.values())
        assert expected_categories.issubset(mapped_categories)

    def test_sarif_prefix_handling(self):
        """Test that SARIF prefixed tools are properly mapped."""
        sarif_tools = [
            ('sarif-trivy', 'container_security'),
            ('sarif-checkov', 'infrastructure_security'),
            ('sarif-gitleaks', 'infrastructure_security'),
            ('sarif-zap', 'web_security'),
            ('sarif-osv', 'dependency_vulnerabilities'),
            ('sarif-semgrep', 'code_vulnerabilities')
        ]

        for tool, expected_category in sarif_tools:
            vulnerability = {
                'id': f'SARIF-{tool}',
                'tool': tool,
                'description': f'Test vulnerability from {tool}'
            }
            category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
            assert category == expected_category, f"Tool {tool} should map to {expected_category}"

    def test_webauthn_pattern_matching(self):
        """Test WebAuthn pattern matching algorithm."""
        # Test individual patterns
        webauthn_patterns = [
            'webauthn', 'fido', 'authenticator', 'credential',
            'attestation', 'assertion', 'challenge', 'passkey'
        ]

        for pattern in webauthn_patterns:
            vulnerability = {
                'id': f'PATTERN-{pattern}',
                'tool': 'semgrep',
                'description': f'Issue with {pattern} implementation',
                'file_path': 'src/auth.js'
            }
            category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
            assert category == 'webauthn_security'
            assert confidence == 0.6  # Single pattern confidence

    def test_case_insensitive_pattern_matching(self):
        """Test that WebAuthn pattern matching is case-insensitive."""
        vulnerability = {
            'id': 'CASE-001',
            'tool': 'semgrep',
            'description': 'Issue with WEBAUTHN and FIDO2 implementation',
            'file_path': 'src/AUTHENTICATION.js'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'webauthn_security'
        assert confidence >= 0.8  # Multiple patterns

    def test_logging_behavior(self):
        """Test that categorizer initializes logger correctly."""
        assert hasattr(self.categorizer, 'logger')
        assert isinstance(self.categorizer.logger, logging.Logger)

    def test_confidence_bounds(self):
        """Test that confidence scores are always within valid bounds [0.0, 1.0]."""
        test_vulnerabilities = [
            {'id': 'BOUND-1', 'tool': 'sarif-trivy', 'description': 'Short', 'severity': 'low'},
            {'id': 'BOUND-2', 'tool': 'osv-scanner', 'description': 'Very long detailed description ' * 10, 'severity': 'CRITICAL'},
            {'id': 'BOUND-3', 'tool': 'zap', 'description': 'Medium length description with some details'},
        ]

        for vulnerability in test_vulnerabilities:
            category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
            assert 0.0 <= confidence <= 1.0, f"Confidence {confidence} out of bounds for {vulnerability['id']}"

    def test_vulnerability_id_fallback(self):
        """Test that categorizer handles missing vulnerability IDs gracefully."""
        vulnerability = {
            'tool': 'semgrep',
            'description': 'Vulnerability without ID field'
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'code_vulnerabilities'  # Should still categorize correctly

    def test_metadata_pattern_matching(self):
        """Test that WebAuthn pattern matching works with metadata field."""
        vulnerability = {
            'id': 'META-001',
            'tool': 'semgrep',
            'description': 'Security issue',
            'metadata': {
                'webauthn_related': True,
                'authentication_method': 'fido2',
                'other_data': 'not relevant'
            }
        }
        category, confidence = self.categorizer.categorize_vulnerability(vulnerability)
        assert category == 'webauthn_security'
        assert confidence >= 0.8  # Multiple patterns in metadata

    def test_comprehensive_tool_coverage(self):
        """Test that all major security scanning tools are supported."""
        required_tools = [
            'trivy', 'sarif-trivy',
            'checkov', 'sarif-checkov',
            'gitleaks', 'sarif-gitleaks',
            'zap', 'sarif-zap',
            'osv-scanner', 'sarif-osv',
            'semgrep', 'sarif-semgrep',
            'mobsf'
        ]

        for tool in required_tools:
            assert tool in self.categorizer.tool_category_map, f"Tool {tool} should be supported"

    def test_error_message_quality(self):
        """Test that error messages provide helpful debugging information."""
        vulnerability = {
            'id': 'ERROR-TEST',
            'tool': 'fictional-scanner',
            'description': 'Test error handling'
        }

        with pytest.raises(ValueError) as exc_info:
            self.categorizer.categorize_vulnerability(vulnerability)

        error_message = str(exc_info.value)
        # Error should contain vulnerability ID, tool name, and supported tools list
        assert 'ERROR-TEST' in error_message
        assert 'fictional-scanner' in error_message
        assert 'Supported tools:' in error_message
        assert 'trivy' in error_message  # Should list at least one supported tool