# Main CI/CD Orchestrator Workflow
#
# This workflow orchestrates the entire CI/CD pipeline using callable workflows
# to eliminate workflow dispatch complexity and ensure reliable execution.
#
# ARCHITECTURE:
# 1. Build & Test: Runs unit tests, builds Docker images with smart change detection
# 2. E2E Tests: Runs only when Docker images are built, uses built images for integration tests
#
# BENEFITS:
# ✅ Eliminates 404 errors (workflows exist in PR branch)
# ✅ No PAT permission issues (direct calls)
# ✅ Modular, maintainable architecture
# ✅ E2E tests run in PRs when Docker images built
# ✅ Preserves all existing conditional logic and optimizations
#
# TRIGGERS:
# - Pull requests to main branch
# - Pushes to main branch
# - Manual dispatch with force options (UI)
#
# MANUAL FORCE OPTIONS:
# - Force full pipeline: Runs unit tests + Docker build + E2E tests + security scanning
# - Force Docker build: Runs Docker build + E2E tests (skips unit tests if no code changes)
# - Force unit tests: Runs unit tests only (skips Docker/E2E)
#
# EXECUTION FLOW:
# PR: build-and-test → e2e-tests (if Docker images built)
# Main: build-and-test → e2e-tests (if Docker images built)
# Manual: force options override smart change detection

name: Main CI/CD Pipeline

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force-full-pipeline:
        description: 'Force full pipeline (unit tests + Docker build + E2E tests + security scanning)'
        required: false
        default: false
        type: boolean
      force-docker-build:
        description: 'Force Docker build and E2E tests (skip unit tests if no code changes)'
        required: false
        default: false
        type: boolean
      force-unit-tests:
        description: 'Force unit tests only (skip Docker/E2E)'
        required: false
        default: false
        type: boolean

permissions:
  # Workflow-level permissions: minimal by default, jobs can request additional permissions
  contents: read

jobs:
  # Job 1: Component change detection for independent processing optimization (Phase 10.1)
  detect-component-changes:
    name: Detect Component Changes
    uses: ./.github/workflows/detect-changes.yml

  # Job 2: Build and test with component-specific conditioning and parallel execution
  build-and-test:
    name: Build & Test (Unit Tests + Docker Images)
    needs: detect-component-changes
    if: |
      needs.detect-component-changes.outputs.should-run-tests-workflow == 'true' ||
      needs.detect-component-changes.outputs.should-run-docker-workflow == 'true' ||
      inputs.force-full-pipeline == true ||
      inputs.force-docker-build == true ||
      inputs.force-unit-tests == true
    uses: ./.github/workflows/build-and-test.yml
    with:
      force-full-pipeline: ${{ inputs.force-full-pipeline || false }}
      force-docker-build: ${{ inputs.force-docker-build || false }}
      force-unit-tests: ${{ inputs.force-unit-tests || false }}
      # Pass component change flags for fine-grained conditioning
      webauthn-server-changed: ${{ needs.detect-component-changes.outputs.webauthn-server-changed }}
      test-credentials-service-changed: ${{ needs.detect-component-changes.outputs.test-credentials-service-changed }}
      openapi-changed: ${{ needs.detect-component-changes.outputs.openapi-changed }}
    permissions:
      contents: read          # Read repository code
      packages: write         # Push Docker images to GHCR
      attestations: write     # Generate build attestations
      id-token: write         # OIDC authentication with registries
      security-events: write  # Upload security scan results (SARIF)
      pull-requests: write
      issues: write
    secrets: inherit

  # Job 3: Generate version for staging client libraries
  generate-staging-version:
    name: Generate Staging Version
    runs-on: ubuntu-latest
    needs: [detect-component-changes]
    if: |
      needs.detect-component-changes.outputs.openapi-changed == 'true' ||
      needs.detect-component-changes.outputs.webauthn-server-changed == 'true' ||
      inputs.force-full-pipeline == true ||
      inputs.force-docker-build == true
    outputs:
      version: ${{ steps.generate-version.outputs.version }}
      is-prerelease: ${{ steps.generate-version.outputs.is-prerelease }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags for version continuity

      - name: Generate staging client version
        id: generate-version
        env:
          BASE_VERSION: "1.0"
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
          GITHUB_PR_NUMBER: ${{ github.event.pull_request.number || '' }}
        run: |
          echo "🎯 Generating staging client version with centralized version manager"
          ./scripts/core/version-manager.sh generate

  # Job 4: Client library publishing (parallel with build-and-test for optimal performance)
  publish-client-libraries:
    name: Publish Client Libraries (Staging)
    needs: [detect-component-changes, generate-staging-version]
    if: |
      always() &&
      needs.generate-staging-version.result == 'success' &&
      (
        needs.detect-component-changes.outputs.openapi-changed == 'true' ||
        needs.detect-component-changes.outputs.webauthn-server-changed == 'true' ||
        inputs.force-full-pipeline == true ||
        inputs.force-docker-build == true
      )
    uses: ./.github/workflows/client-publish.yml
    permissions:
      contents: write  # Required for creating GitHub releases and tags
      packages: write  # Required for publishing to GitHub Packages
      id-token: write  # Required for npm publishing
    with:
      publish-type: "staging"
      client-version: ${{ needs.generate-staging-version.outputs.version }}
      workflow-identifier: ${{ github.event.pull_request.number || github.run_number || 'N/A' }}
    secrets:
      GRADLE_ENCRYPTION_KEY: ${{ secrets.GRADLE_ENCRYPTION_KEY }}

  # Job 5: E2E tests using built Docker images with smart component-based triggering (waits for both build AND client publishing)
  e2e-tests:
    name: E2E Tests (Web + Android)
    needs: [detect-component-changes, build-and-test, publish-client-libraries]
    if: |
      always() &&
      (
        (needs.detect-component-changes.outputs.webauthn-server-changed == 'true' && needs.build-and-test.result == 'success') ||
        (needs.detect-component-changes.outputs.test-credentials-service-changed == 'true' && needs.build-and-test.result == 'success') ||
        (needs.detect-component-changes.outputs.openapi-changed == 'true' && needs.publish-client-libraries.result == 'success') ||
        (needs.detect-component-changes.outputs.e2e-tests-changed == 'true' && (needs.build-and-test.result == 'success' || needs.build-and-test.result == 'skipped'))
      ) &&
      needs.build-and-test.outputs.docker_images_built == 'true'
    uses: ./.github/workflows/e2e-tests.yml
    permissions:
      contents: write         # Required for GitHub release creation
      packages: write          # Pull/Push Docker images from GHCR
      pull-requests: write    # Comment on PRs with test results
      id-token: write         # Required for npm publishing
    with:
      workflow-identifier: ${{ github.event.pull_request.number || github.run_number || 'N/A' }}
      webauthn_server_image: ${{ needs.build-and-test.outputs.webauthn_server_image }}
      test_credentials_image: ${{ needs.build-and-test.outputs.test_credentials_image }}
      # Pass component change flags for smart E2E conditioning
      webauthn-server-changed: ${{ needs.detect-component-changes.outputs.webauthn-server-changed }}
      test-credentials-service-changed: ${{ needs.detect-component-changes.outputs.test-credentials-service-changed }}
      openapi-changed: ${{ needs.detect-component-changes.outputs.openapi-changed }}
      e2e-tests-changed: ${{ needs.detect-component-changes.outputs.e2e-tests-changed }}
      # Pass granular E2E change flags for platform-specific triggering
      web-e2e-test-files-changed: ${{ needs.detect-component-changes.outputs.web-e2e-test-files-changed }}
      android-e2e-test-files-changed: ${{ needs.detect-component-changes.outputs.android-e2e-test-files-changed }}
    secrets: inherit

  # Job 6: Security scanning using built Docker images (parallel with E2E tests)  
  security-scanning:
    name: Security Scanning (Docker Images)
    needs: [detect-component-changes, build-and-test]
    if: |
      always() &&
      needs.build-and-test.outputs.docker_images_built == 'true' &&
      (
        needs.detect-component-changes.outputs.webauthn-server-changed == 'true' ||
        needs.detect-component-changes.outputs.test-credentials-service-changed == 'true' ||
        needs.detect-component-changes.outputs.workflows-changed == 'true'
      )
    uses: ./.github/workflows/docker-security-scan.yml
    permissions:
      contents: read          # Read repository code
      security-events: write  # Upload SARIF results to GitHub Security
      pull-requests: write    # Comment on PRs with scan results
      issues: write          # Update issues with security findings
    with:
      webauthn-server-image: ${{ needs.build-and-test.outputs.webauthn_server_image }}
      test-credentials-image: ${{ needs.build-and-test.outputs.test_credentials_image }}
      registry-url: 'ghcr.io'
      skip-scan: false
    secrets: inherit

  # Job 7: Setup configuration for production publishing (main branch only)
  setup-production-config:
    name: Setup Production Configuration
    runs-on: ubuntu-latest
    needs: [ detect-component-changes, build-and-test, generate-staging-version, publish-client-libraries, e2e-tests, security-scanning ]
    if: |
      always() &&
      github.ref_name == 'main' &&
      needs.build-and-test.result == 'success' &&
      (needs.e2e-tests.result == 'success' || needs.e2e-tests.result == 'skipped') &&
      (needs.security-scanning.outputs.security-scan-passed == 'true' || needs.security-scanning.result == 'skipped') &&
      (
        needs.detect-component-changes.outputs.webauthn-server-changed == 'true' ||
        needs.detect-component-changes.outputs.test-credentials-service-changed == 'true' ||
        needs.detect-component-changes.outputs.openapi-changed == 'true'
      )
    outputs:
      java-version: ${{ steps.config.outputs.java-version }}
      docker-registry: ${{ steps.config.outputs.docker-registry }}
      webauthn-image-name: ${{ steps.config.outputs.webauthn-image-name }}
      test-credentials-image-name: ${{ steps.config.outputs.test-credentials-image-name }}
      base-version: ${{ steps.config.outputs.base-version }}
      npm-scope: ${{ steps.config.outputs.npm-scope }}
      npm-package-name: ${{ steps.config.outputs.npm-package-name }}
      client-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags for version continuity

      - name: Load configuration from central config file
        id: config
        env:
          PUBLISHING_CONFIG_FILE: "config/publishing-config.yml"
          JAVA_VERSION: "21"
          BASE_VERSION: "1.0"
        run: |
          echo "🔧 Loading production configuration from $PUBLISHING_CONFIG_FILE..."
          
          # Validate configuration file exists
          if [ ! -f "$PUBLISHING_CONFIG_FILE" ]; then
            echo "❌ Configuration file not found: $PUBLISHING_CONFIG_FILE"
            exit 1
          fi
          
          # Extract Docker configuration values
          DOCKER_REGISTRY=$(yq '.docker.registry.url' "$PUBLISHING_CONFIG_FILE")
          WEBAUTHN_IMAGE_NAME=$(yq '.docker.images.webauthn-server.name' "$PUBLISHING_CONFIG_FILE")
          TEST_CREDENTIALS_IMAGE_NAME=$(yq '.docker.images.test-credentials-service.name' "$PUBLISHING_CONFIG_FILE")
          
          # Extract npm configuration
          NPM_SCOPE=$(yq '.packages.typescript.scope.production' "$PUBLISHING_CONFIG_FILE")
          NPM_PACKAGE_NAME=$(yq '.packages.typescript.basePackageName' "$PUBLISHING_CONFIG_FILE")
          
          # Validate required values are not null
          if [ "$DOCKER_REGISTRY" = "null" ] || [ "$WEBAUTHN_IMAGE_NAME" = "null" ] || 
             [ "$TEST_CREDENTIALS_IMAGE_NAME" = "null" ] || [ "$NPM_SCOPE" = "null" ] || 
             [ "$NPM_PACKAGE_NAME" = "null" ]; then
            echo "❌ Missing required configuration in $PUBLISHING_CONFIG_FILE"
            echo "Registry: $DOCKER_REGISTRY"
            echo "WebAuthn image: $WEBAUTHN_IMAGE_NAME"
            echo "Test credentials image: $TEST_CREDENTIALS_IMAGE_NAME"
            echo "NPM scope: $NPM_SCOPE"
            echo "NPM package name: $NPM_PACKAGE_NAME"
            exit 1
          fi
          
          # Set outputs
          echo "java-version=$JAVA_VERSION" >> $GITHUB_OUTPUT
          echo "docker-registry=$DOCKER_REGISTRY" >> $GITHUB_OUTPUT
          echo "webauthn-image-name=$WEBAUTHN_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "test-credentials-image-name=$TEST_CREDENTIALS_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "base-version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "npm-scope=$NPM_SCOPE" >> $GITHUB_OUTPUT
          echo "npm-package-name=$NPM_PACKAGE_NAME" >> $GITHUB_OUTPUT
          
          echo "✅ Production configuration loaded successfully:"
          echo "  Docker Registry: $DOCKER_REGISTRY"
          echo "  WebAuthn Server: $WEBAUTHN_IMAGE_NAME"
          echo "  Test Credentials: $TEST_CREDENTIALS_IMAGE_NAME"
          echo "  NPM Scope: $NPM_SCOPE"
          echo "  NPM Package: $NPM_PACKAGE_NAME"

      - name: Generate production version
        id: version
        env:
          BASE_VERSION: ${{ steps.config.outputs.base-version }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          echo "🎯 Generating production client version with centralized version manager"
          ./scripts/core/version-manager.sh generate

  # Job 8a: Publish Docker images to Docker Hub (conditional on component changes)
  publish-docker-production:
    name: Publish Docker Images to Docker Hub
    needs: [ detect-component-changes, build-and-test, generate-staging-version, publish-client-libraries, e2e-tests, security-scanning, setup-production-config ]
    if: |
      always() &&
      github.ref_name == 'main' &&
      needs.setup-production-config.result == 'success' &&
      (
        needs.detect-component-changes.outputs.webauthn-server-changed == 'true' ||
        needs.detect-component-changes.outputs.test-credentials-service-changed == 'true'
      )
    uses: ./.github/workflows/publish-docker.yml
    with:
      docker-registry: ${{ needs.setup-production-config.outputs.docker-registry }}
      webauthn-server-changed: ${{ needs.detect-component-changes.outputs.webauthn-server-changed }}
      test-credentials-changed: ${{ needs.detect-component-changes.outputs.test-credentials-service-changed }}
      publish-from-main-ci: "true"
      github-run-number: ${{ github.run_number }}
    secrets:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
    permissions:
      contents: write     # Required for creating GitHub releases
      attestations: write # Required for production attestation generation
      id-token: write     # Required for Sigstore signing
      packages: read      # Required for pulling from GHCR

  # Job 8b: Publish client libraries in parallel (conditional on OpenAPI changes)
  publish-clients-production:
    name: Publish Client Libraries
    needs: [ detect-component-changes, build-and-test, generate-staging-version, publish-client-libraries, e2e-tests, security-scanning, setup-production-config ]
    if: |
      always() &&
      github.ref_name == 'main' &&
      needs.setup-production-config.result == 'success' &&
      (
        needs.detect-component-changes.outputs.openapi-changed == 'true' ||
        needs.detect-component-changes.outputs.webauthn-server-changed == 'true'
      )
    uses: ./.github/workflows/client-publish.yml
    with:
      publish-type: "production"
      client-version: ${{ needs.setup-production-config.outputs.client-version }}
      workflow-identifier: "production"
    permissions:
      contents: write  # Required for creating GitHub releases and tags
      packages: write  # Required for publishing to GitHub Packages
      id-token: write  # Required for npm publishing
    secrets:
      GRADLE_ENCRYPTION_KEY: ${{ secrets.GRADLE_ENCRYPTION_KEY }}
      NPM_PUBLISH_TOKEN: ${{ secrets.NPM_PUBLISH_TOKEN }}
      CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
      CENTRAL_PORTAL_PASSWORD: ${{ secrets.CENTRAL_PORTAL_PASSWORD }}
      SIGNING_KEY: ${{ secrets.SIGNING_KEY }}
      SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

  # Job 9: Report pipeline status with component-aware result analysis
  report-pipeline-status:
    name: Report Pipeline Status
    runs-on: ubuntu-latest
    needs: [ detect-component-changes, build-and-test, generate-staging-version, publish-client-libraries, e2e-tests, security-scanning, setup-production-config, publish-docker-production, publish-clients-production ]
    if: always()
    outputs:
      pipeline-success: ${{ steps.determine-outcome.outputs.pipeline-success }}
      workflow-outcome: ${{ steps.determine-outcome.outputs.workflow-outcome }}
    steps:
      - name: Report overall pipeline status
        run: |
          echo "🏗️ CI/CD Pipeline Results Summary (Component-Aware Parallel Execution):"
          echo "📊 Component Changes Detected:"
          echo "  WebAuthn Server: ${{ needs.detect-component-changes.outputs.webauthn-server-changed }}"
          echo "  Test Credentials Service: ${{ needs.detect-component-changes.outputs.test-credentials-service-changed }}"
          echo "  OpenAPI Specification: ${{ needs.detect-component-changes.outputs.openapi-changed }}"
          echo "  E2E Tests: ${{ needs.detect-component-changes.outputs.e2e-tests-changed }}"
          echo "  Workflows: ${{ needs.detect-component-changes.outputs.workflows-changed }}"
          echo ""
          echo "🚀 Pipeline Execution Results:"
          echo "Build & Test: ${{ needs.build-and-test.result }}"
          echo "Docker Images Built: ${{ needs.build-and-test.outputs.docker_images_built }}"
          echo "E2E Tests: ${{ needs.e2e-tests.result }}"
          echo "Security Scanning: ${{ needs.security-scanning.result }}"
          
          # Production publishing results (main branch only)
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            echo "📦 Production Publishing (Main Branch):"
            echo "  Configuration Setup: ${{ needs.setup-production-config.result }}"
            echo "  Docker Publishing: ${{ needs.publish-docker-production.result }}"
            echo "  Client Publishing: ${{ needs.publish-clients-production.result }}"
            
            # Docker publishing results
            if [[ "${{ needs.publish-docker-production.result }}" == "success" ]]; then
              echo "  ✅ Docker Images Published: ${{ needs.publish-docker-production.outputs.docker-published }}"
            elif [[ "${{ needs.publish-docker-production.result }}" == "failure" ]]; then
              echo "  ❌ Docker publishing failed"
            else
              echo "  ⏸️ Docker publishing was skipped or cancelled"
            fi
            
            # Client publishing results
            if [[ "${{ needs.publish-clients-production.result }}" == "success" ]]; then
              echo "  ✅ Client Libraries Published: TypeScript and Android"
            elif [[ "${{ needs.publish-clients-production.result }}" == "failure" ]]; then
              echo "  ❌ Client publishing failed"
            else
              echo "  ⏸️ Client publishing was skipped or cancelled"
            fi
          else
            echo "📦 Production Publishing: Skipped (not main branch)"
          fi

          # Check if build phase failed
          if [[ "${{ needs.build-and-test.result }}" != "success" ]]; then
            echo "❌ Build and test phase failed"
            exit 1
          fi

          echo "✅ Build and test phase completed successfully"

          if [[ "${{ needs.build-and-test.outputs.docker_images_built }}" == "true" ]]; then
            echo "🐳 Docker images were built:"
            echo "  WebAuthn Server: ${{ needs.build-and-test.outputs.webauthn_server_image }}"
            echo "  Test Credentials: ${{ needs.build-and-test.outputs.test_credentials_image }}"

            # Check security scanning results (critical for pipeline success)
            if [[ "${{ needs.security-scanning.result }}" == "failure" ]]; then
              echo "🚨 Security scanning failed - blocking pipeline"
              echo "Critical vulnerabilities found: ${{ needs.security-scanning.outputs.critical-vulnerabilities }}"
              echo "❌ Pipeline blocked due to security issues"
              exit 1
            elif [[ "${{ needs.security-scanning.result }}" == "success" ]]; then
              if [[ "${{ needs.security-scanning.outputs.security-scan-passed }}" == "true" ]]; then
                echo "🔒 Security scanning passed - no critical vulnerabilities"
              else
                echo "🚨 Security scanning completed but found issues"
                echo "Critical vulnerabilities: ${{ needs.security-scanning.outputs.critical-vulnerabilities }}"
                exit 1
              fi
            else
              echo "⏸️ Security scanning was skipped or cancelled"
            fi

            # Check E2E test results
            if [[ "${{ needs.e2e-tests.result }}" == "success" ]]; then
              echo "🧪 E2E tests passed successfully"
            elif [[ "${{ needs.e2e-tests.result }}" == "failure" ]]; then
              echo "❌ E2E tests failed - check integration test results"
              exit 1
            else
              echo "⏸️ E2E tests were skipped or cancelled"
            fi

            # Overall success summary
            if [[ "${{ needs.security-scanning.outputs.security-scan-passed }}" == "true" && "${{ needs.e2e-tests.result }}" == "success" ]]; then
              echo "🎉 Complete CI/CD pipeline passed:"
              echo "  ✅ Security scanning: No critical vulnerabilities"
              echo "  ✅ E2E testing: All integration tests successful"
              echo "  ⚡ Performance: Parallel execution optimized pipeline time"
              
              # Production publishing summary (main branch only)
              if [[ "${{ github.ref_name }}" == "main" ]]; then
                DOCKER_SUCCESS="${{ needs.publish-docker-production.result }}"
                CLIENT_SUCCESS="${{ needs.publish-clients-production.result }}"
                
                if [[ "$DOCKER_SUCCESS" == "success" || "$CLIENT_SUCCESS" == "success" ]]; then
                  echo "🚀 Production artifacts published successfully:"
                  if [[ "$DOCKER_SUCCESS" == "success" ]]; then
                    echo "  📦 Docker images published to Docker Hub"
                  fi
                  if [[ "$CLIENT_SUCCESS" == "success" ]]; then
                    echo "  📚 Client libraries published to production registries"
                  fi
                fi
              fi
            fi
          else
            echo "⚡ Fast path completed - no Docker builds needed (docs/workflow changes only)"
          fi

      - name: Determine workflow outcome for cleanup
        id: determine-outcome
        run: |
          # Determine overall pipeline success for staging cleanup
          PIPELINE_SUCCESS=false
          WORKFLOW_OUTCOME="failure"

          # Component-aware pipeline success logic:
          # 1. Fast path: Only documentation/infrastructure changes (no builds needed)
          # 2. Component path: Component changes with successful builds/tests
          # 3. Main branch: All above + conditional production publishing
          if [[ "${{ needs.build-and-test.result }}" == "success" || "${{ needs.build-and-test.result }}" == "skipped" ]]; then
            if [[ "${{ needs.build-and-test.outputs.docker_images_built }}" != "true" ]]; then
              # Fast path - no Docker builds needed (docs/infrastructure only)
              PIPELINE_SUCCESS=true
              WORKFLOW_OUTCOME="success"
            elif [[ ("${{ needs.security-scanning.outputs.security-scan-passed }}" == "true" || "${{ needs.security-scanning.result }}" == "skipped") && ("${{ needs.e2e-tests.result }}" == "success" || "${{ needs.e2e-tests.result }}" == "skipped") ]]; then
              # Full pipeline with Docker builds - all tests passed
              if [[ "${{ github.ref_name }}" == "main" ]]; then
                # Main branch - also check production publishing
                DOCKER_SUCCESS="${{ needs.publish-docker-production.result }}"
                CLIENT_SUCCESS="${{ needs.publish-clients-production.result }}"
                CONFIG_SUCCESS="${{ needs.setup-production-config.result }}"
                
                if [[ "$CONFIG_SUCCESS" != "success" ]]; then
                  # Production config failed, but tests passed - still consider success
                  echo "⚠️ Production configuration failed, but core pipeline succeeded"
                  PIPELINE_SUCCESS=true
                  WORKFLOW_OUTCOME="success"
                elif [[ "$DOCKER_SUCCESS" == "success" || "$CLIENT_SUCCESS" == "success" || ("$DOCKER_SUCCESS" == "skipped" && "$CLIENT_SUCCESS" == "skipped") ]]; then
                  # At least one production publishing succeeded OR both were skipped
                  PIPELINE_SUCCESS=true
                  WORKFLOW_OUTCOME="success"
                else
                  # Both production publishing attempts failed
                  echo "❌ All production publishing failed on main branch"
                  echo "  Docker: $DOCKER_SUCCESS, Clients: $CLIENT_SUCCESS"
                fi
              else
                # Non-main branch - standard success criteria
                PIPELINE_SUCCESS=true
                WORKFLOW_OUTCOME="success"
              fi
            fi
          fi

          echo "pipeline-success=$PIPELINE_SUCCESS" >> $GITHUB_OUTPUT
          echo "workflow-outcome=$WORKFLOW_OUTCOME" >> $GITHUB_OUTPUT

          echo "📊 Workflow outcome for staging cleanup: $WORKFLOW_OUTCOME"
          echo "🎯 Pipeline success status: $PIPELINE_SUCCESS"

  # Job 10: Final cleanup after production publishing (component-aware)
  final-cleanup:
    name: Final Cleanup
    runs-on: ubuntu-latest
    needs: [ detect-component-changes, build-and-test, generate-staging-version, publish-client-libraries, e2e-tests, security-scanning, setup-production-config, publish-docker-production, publish-clients-production, report-pipeline-status ]
    if: always()
    permissions:
      contents: read          # Read repository code and git history
      packages: write         # Package access for cleanup operations
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch recent commits to check for [preserve] keyword

      - name: Check for emergency preserve override
        id: check-preserve
        run: |
          # Check latest commit message for [preserve] keyword
          if git log -1 --pretty=%s | grep -i '\[preserve\]' >/dev/null; then
            echo "🚨 EMERGENCY OVERRIDE: [preserve] keyword found in commit message"
            echo "preserve-override=true" >> $GITHUB_OUTPUT
          else
            echo "preserve-override=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine cleanup strategy
        id: cleanup-strategy
        run: |
          echo "🧹 Determining cleanup strategy based on context..."
          echo "📋 Context Analysis:"
          echo "  Event: ${{ github.event_name }}"
          echo "  Branch: ${{ github.ref_name }}"
          echo "  Workflow outcome: ${{ needs.report-pipeline-status.outputs.workflow-outcome }}"
          echo "  Emergency preserve: ${{ steps.check-preserve.outputs.preserve-override }}"
          echo ""
          
          CLEANUP_TYPE="none"
          CLEANUP_SCOPE="none"
          
          if [[ "${{ steps.check-preserve.outputs.preserve-override }}" == "true" ]]; then
            echo "🚨 Emergency preserve override - skipping all cleanup"
            CLEANUP_TYPE="preserve"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "📦 Pull request cleanup - staging artifacts only"
            CLEANUP_TYPE="staging"
            CLEANUP_SCOPE="pr-artifacts"
          elif [[ "${{ github.ref_name }}" == "main" && ("${{ needs.publish-docker-production.result }}" == "success" || "${{ needs.publish-clients-production.result }}" == "success") ]]; then
            echo "🚀 Main branch with successful production publishing - GHCR cleanup"
            CLEANUP_TYPE="production"
            CLEANUP_SCOPE="ghcr-staging"
          else
            echo "⏭️ No cleanup needed for this context"
          fi
          
          echo "cleanup-type=$CLEANUP_TYPE" >> $GITHUB_OUTPUT
          echo "cleanup-scope=$CLEANUP_SCOPE" >> $GITHUB_OUTPUT
          
          echo "🎯 Cleanup Decision: $CLEANUP_TYPE ($CLEANUP_SCOPE)"

      - name: Execute cleanup based on strategy
        if: steps.cleanup-strategy.outputs.cleanup-type == 'staging' || steps.cleanup-strategy.outputs.cleanup-type == 'production'
        env:
          GH_TOKEN: ${{ secrets.PACKAGE_ADMIN_TOKEN }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_PR_NUMBER: ${{ github.event.pull_request.number || '' }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          DOCKER_WEBAUTHN_IMAGE_NAME: "webauthn-server"
          DOCKER_TEST_CREDENTIALS_IMAGE_NAME: "webauthn-test-credentials-service"
          # Set FORCE_DOCKER_CLEANUP for production cleanup to override preservation logic
          FORCE_DOCKER_CLEANUP: ${{ steps.cleanup-strategy.outputs.cleanup-type == 'production' && 'true' || 'false' }}
        run: |
          CLEANUP_TYPE="${{ steps.cleanup-strategy.outputs.cleanup-type }}"
          CLEANUP_SCOPE="${{ steps.cleanup-strategy.outputs.cleanup-scope }}"
          WORKFLOW_OUTCOME="${{ needs.report-pipeline-status.outputs.workflow-outcome }}"
          
          # Display context-specific information
          if [[ "$CLEANUP_TYPE" == "staging" ]]; then
            echo "🧹 Starting smart staging cleanup for PR"
            echo "📋 Cleanup scope: GitHub Packages staging artifacts"
            echo "🎯 Workflow outcome: $WORKFLOW_OUTCOME"
            echo ""
            
            case "$WORKFLOW_OUTCOME" in
              "success")
                echo "✅ Workflow succeeded - performing COMPLETE staging cleanup"
                echo "🗑️ Strategy: Delete ALL staging packages (validation complete, no longer needed)"
                ;;
              "failure")
                echo "❌ Workflow failed - performing CONSERVATIVE staging cleanup"
                echo "🔍 Strategy: Keep last 5 staging versions for debugging"
                ;;
            esac
          elif [[ "$CLEANUP_TYPE" == "production" ]]; then
            echo "🧹 Final GHCR cleanup after production publishing"
            echo "📦 Docker Image Lifecycle Coordination - Final cleanup step"
            echo "✅ Production publishing successful - performing final GHCR cleanup"
            echo "🗑️ Removing preserved Docker images from GHCR after DockerHub publication"
            # Main branch cleanup always uses "success" since it only runs after successful production publishing
            WORKFLOW_OUTCOME="success"
          fi
          echo ""

          # Execute cleanup script (same script, same logic for both scenarios)
          chmod +x scripts/docker/cleanup-staging-packages.sh
          scripts/docker/cleanup-staging-packages.sh "$WORKFLOW_OUTCOME" "${{ github.repository_owner }}"

      - name: Report cleanup summary
        if: always()
        run: |
          echo "📋 Final Cleanup Summary:"
          echo "  Cleanup Type: ${{ steps.cleanup-strategy.outputs.cleanup-type }}"
          echo "  Cleanup Scope: ${{ steps.cleanup-strategy.outputs.cleanup-scope }}"
          echo "  Emergency Override: ${{ steps.check-preserve.outputs.preserve-override }}"
          echo "  Workflow Outcome: ${{ needs.report-pipeline-status.outputs.workflow-outcome }}"
          echo "  Pipeline Success: ${{ needs.report-pipeline-status.outputs.pipeline-success }}"
          echo ""

          case "${{ steps.cleanup-strategy.outputs.cleanup-type }}" in
            "preserve")
              echo "🚨 All cleanup skipped due to emergency override"
              ;;
            "staging")
              if [[ "${{ needs.report-pipeline-status.outputs.workflow-outcome }}" == "success" ]]; then
                echo "🎉 Complete staging cleanup performed - all staging artifacts removed"
                echo "✅ GitHub Packages staging cleanup completed successfully"
              else
                echo "🔍 Conservative staging cleanup performed - debugging artifacts preserved"
                echo "⚠️  Some staging packages retained for investigation"
              fi
              ;;
            "production")
              echo "🚀 Production GHCR cleanup completed - staging images removed after DockerHub publication"
              echo "✅ Docker Image Lifecycle Coordination: GHCR→DockerHub→Cleanup cycle completed"
              ;;
            "none")
              echo "⏭️ No cleanup performed for this workflow context"
              ;;
          esac

