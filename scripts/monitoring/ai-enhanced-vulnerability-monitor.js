#!/usr/bin/env node

/**
 * AI-Enhanced Vulnerability Monitor for WebAuthn Security
 * 
 * Enhances the existing vulnerability monitoring with AI-powered capabilities:
 * - Intelligent vulnerability analysis and correlation
 * - Complete test implementation generation (not just stubs)
 * - Cross-reference analysis with actual codebase patterns
 * - Proactive security pattern recognition
 * - Zero-day vulnerability detection through pattern analysis
 * 
 * INTEGRATION WITH EXISTING SYSTEM:
 * - Extends existing VulnerabilityMonitor class
 * - Uses same vulnerability-tracking.json database
 * - Maintains compatibility with existing workflow
 * - Enhances test generation with complete implementations
 * 
 * AI CAPABILITIES:
 * - CVE impact analysis specific to our WebAuthn implementation
 * - Automatic test case generation with actual logic
 * - Security pattern recognition for undisclosed vulnerabilities
 * - Code correlation to determine actual risk
 */

import fs from 'fs';
import path from 'path';
import https from 'https';
import { spawn } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import existing vulnerability monitor
const VulnerabilityMonitorModule = await import('./vulnerability-monitor.js');
const VulnerabilityMonitor = VulnerabilityMonitorModule.default;

class AIEnhancedVulnerabilityMonitor extends VulnerabilityMonitor {
    constructor() {
        super();
        
        // AI Configuration
        this.aiConfig = {
            apiKey: process.env.ANTHROPIC_API_KEY,
            model: 'claude-3-5-sonnet-20241022',
            maxTokens: 4000,
            temperature: 0.1 // Low temperature for consistent security analysis
        };
        
        // Enhanced analysis paths
        this.webauthnAgentPath = path.join(__dirname, '../.claude/agents/webauthn-security-analysis.md');
        this.codebaseAnalysisCache = new Map();
        this.securityPatternCache = new Map();
        
        // Load security context
        this.securityContext = this.loadSecurityContext();
    }

    loadSecurityContext() {
        try {
            const context = {
                webauthnAgent: '',
                existingTests: '',
                codebase: {},
                securityPatterns: []
            };
            
            // Load WebAuthn Security Agent
            if (fs.existsSync(this.webauthnAgentPath)) {
                context.webauthnAgent = fs.readFileSync(this.webauthnAgentPath, 'utf8');
                console.log('‚úÖ WebAuthn Security Agent loaded');
            }
            
            // Load existing security tests for pattern analysis
            const testPath = path.join(__dirname, '../webauthn-server/src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt');
            if (fs.existsSync(testPath)) {
                context.existingTests = fs.readFileSync(testPath, 'utf8');
                console.log('‚úÖ Existing security tests loaded');
            }
            
            // Load key security-related files for analysis
            const securityFiles = [
                '../webauthn-server/src/main/kotlin/com/vmenon/mpo/api/authn/routes/AuthenticationRoutes.kt',
                '../webauthn-server/src/main/kotlin/com/vmenon/mpo/api/authn/routes/RegistrationRoutes.kt',
                '../webauthn-server/src/main/kotlin/com/vmenon/mpo/api/authn/service/WebAuthnService.kt'
            ];
            
            for (const file of securityFiles) {
                const fullPath = path.join(__dirname, file);
                if (fs.existsSync(fullPath)) {
                    const relativePath = path.relative(__dirname, fullPath);
                    context.codebase[relativePath] = fs.readFileSync(fullPath, 'utf8').substring(0, 10000);
                }
            }
            
            console.log(`‚úÖ Security context loaded: ${Object.keys(context.codebase).length} code files`);
            return context;
            
        } catch (error) {
            console.warn('‚ö†Ô∏è  Failed to load complete security context:', error.message);
            return { webauthnAgent: '', existingTests: '', codebase: {}, securityPatterns: [] };
        }
    }

    async enhancedVulnerabilityAnalysis(vulnerabilities, libraryData, libraryStatus) {
        if (vulnerabilities.length === 0) {
            console.log('‚ÑπÔ∏è  No vulnerabilities to analyze');
            return [];
        }

        console.log(`ü§ñ Starting AI-enhanced analysis of ${vulnerabilities.length} vulnerabilities...`);
        
        const enhancedVulnerabilities = [];
        
        for (const vuln of vulnerabilities) {
            try {
                console.log(`üîç Analyzing ${vuln.id}...`);
                
                // Perform AI-enhanced vulnerability analysis
                const analysis = await this.performAIVulnerabilityAnalysis(vuln, libraryData, libraryStatus);
                
                // Generate complete test implementation (not just stub)
                const testImplementation = await this.generateCompleteTestImplementation(vuln, analysis);
                
                // Assess actual risk to our codebase
                const riskAssessment = await this.assessCodebaseRisk(vuln, analysis);
                
                const enhancedVuln = {
                    ...vuln,
                    aiAnalysis: analysis,
                    testImplementation: testImplementation,
                    riskAssessment: riskAssessment,
                    enhancedDate: new Date().toISOString(),
                    requiresImmediateAction: riskAssessment.criticalRisk
                };
                
                enhancedVulnerabilities.push(enhancedVuln);
                
                // Brief pause to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 1000));
                
            } catch (error) {
                console.error(`‚ùå AI analysis failed for ${vuln.id}:`, error.message);
                
                // Fallback to original vulnerability with error note
                enhancedVulnerabilities.push({
                    ...vuln,
                    aiAnalysisError: error.message,
                    testImplementation: this.generateTestForVulnerability(vuln), // Use original method
                    requiresImmediateAction: false
                });
            }
        }
        
        console.log(`‚úÖ AI-enhanced analysis completed for ${enhancedVulnerabilities.length} vulnerabilities`);
        return enhancedVulnerabilities;
    }

    async performAIVulnerabilityAnalysis(vulnerability, libraryData, libraryStatus) {
        if (!this.aiConfig.apiKey) {
            console.warn('‚ö†Ô∏è  ANTHROPIC_API_KEY not set - skipping AI analysis');
            return { analysisSkipped: true, reason: 'No API key' };
        }

        const prompt = this.buildVulnerabilityAnalysisPrompt(vulnerability, libraryData, libraryStatus);
        
        try {
            const response = await this.callAnthropicAPI(prompt);
            return this.parseAIAnalysisResponse(response);
        } catch (error) {
            console.error(`‚ùå AI analysis failed for ${vulnerability.id}:`, error.message);
            return { analysisError: error.message };
        }
    }

    buildVulnerabilityAnalysisPrompt(vulnerability, libraryData, libraryStatus) {
        return `You are a WebAuthn security expert analyzing a newly discovered vulnerability for its impact on our specific implementation.

SECURITY CONTEXT:
${this.securityContext.webauthnAgent}

VULNERABILITY DETAILS:
- ID: ${vulnerability.id}
- Name: ${vulnerability.name}
- Description: ${vulnerability.description}
- Severity: ${vulnerability.severity}
- CVSS Score: ${vulnerability.cvssScore}
- Source: ${vulnerability.source}
- Affected Components: ${vulnerability.affectedComponents?.join(', ') || 'Unknown'}

CURRENT LIBRARY STATUS:
- java-webauthn-server version: ${libraryStatus.currentVersion || 'Unknown'}
- Latest available version: ${libraryData.releases?.[0]?.tag_name || 'Unknown'}

OUR CODEBASE CONTEXT:
${Object.entries(this.securityContext.codebase).map(([file, content]) => 
  `--- ${file} ---\n${content.substring(0, 2000)}`
).join('\n\n')}

EXISTING SECURITY TESTS:
${this.securityContext.existingTests.substring(0, 3000)}

ANALYSIS REQUIREMENTS:
1. **Impact Assessment**: How does this vulnerability specifically affect our KTor + Yubico implementation?
2. **Library Mitigation**: Is this vulnerability already handled by our java-webauthn-server version?
3. **Code Pattern Analysis**: Do our existing code patterns expose us to this vulnerability?
4. **Attack Vector Feasibility**: How realistic is this attack vector in our architecture?
5. **Defense Effectiveness**: Do our existing security measures protect against this?

RESPONSE FORMAT (JSON):
{
  "impactAssessment": {
    "relevantToOurImplementation": <boolean>,
    "severityInOurContext": "CRITICAL|HIGH|MEDIUM|LOW|NONE",
    "affectedComponents": ["list of our components that could be affected"],
    "attackVectorFeasibility": "HIGH|MEDIUM|LOW|NONE",
    "exploitComplexity": "LOW|MEDIUM|HIGH"
  },
  "libraryMitigation": {
    "isLibraryVulnerable": <boolean>,
    "mitigationAvailable": <boolean>,
    "recommendedLibraryVersion": "version string or null",
    "mitigationDetails": "explanation of how library handles this"
  },
  "codebaseAnalysis": {
    "vulnerablePatterns": ["patterns in our code that could be exploited"],
    "protectivePatterns": ["existing patterns that provide protection"],
    "codeChangesNeeded": ["specific code changes required"],
    "configurationChanges": ["configuration changes needed"]
  },
  "testStrategy": {
    "testObjective": "what the test should verify",
    "attackSimulation": "how to simulate the attack",
    "successCriteria": "what indicates the test passed",
    "specificAssertions": ["exact assertions needed in the test"]
  },
  "recommendedActions": {
    "immediate": ["actions needed immediately"],
    "shortTerm": ["actions needed within days/weeks"],
    "longTerm": ["actions for future consideration"]
  },
  "riskScore": <0-10 float for our specific implementation>
}

Focus on practical, actionable analysis specific to our WebAuthn server implementation.`;
    }

    async generateCompleteTestImplementation(vulnerability, analysis) {
        if (!this.aiConfig.apiKey) {
            console.warn('‚ö†Ô∏è  Falling back to basic test generation');
            return {
                testCode: this.generateTestForVulnerability(vulnerability),
                implementation: 'basic',
                aiGenerated: false
            };
        }

        const prompt = this.buildTestGenerationPrompt(vulnerability, analysis);
        
        try {
            const response = await this.callAnthropicAPI(prompt);
            const testCode = this.extractTestCode(response);
            
            return {
                testCode: testCode,
                implementation: 'complete',
                aiGenerated: true,
                generatedAt: new Date().toISOString()
            };
        } catch (error) {
            console.error(`‚ùå Test generation failed for ${vulnerability.id}:`, error.message);
            return {
                testCode: this.generateTestForVulnerability(vulnerability),
                implementation: 'fallback',
                aiGenerated: false,
                error: error.message
            };
        }
    }

    buildTestGenerationPrompt(vulnerability, analysis) {
        return `Generate a complete, executable Kotlin security test for this WebAuthn vulnerability.

VULNERABILITY: ${vulnerability.id}
${vulnerability.description}

AI ANALYSIS RESULTS:
${JSON.stringify(analysis, null, 2)}

EXISTING TEST PATTERNS:
${this.securityContext.existingTests.substring(0, 4000)}

REQUIREMENTS:
1. Generate a complete, runnable Kotlin test method
2. Follow existing test structure and patterns exactly
3. Use testApplication { application { module(testStorageModule) } }
4. Use WebAuthnTestHelpers for test data generation
5. Include specific attack simulation based on the vulnerability
6. Add proper assertions that verify protection is in place
7. Include meaningful comments explaining the vulnerability and test approach

SPECIFIC ATTACK SIMULATION:
${analysis.testStrategy ? 
  `- Objective: ${analysis.testStrategy.testObjective}
- Attack Simulation: ${analysis.testStrategy.attackSimulation}
- Success Criteria: ${analysis.testStrategy.successCriteria}
- Assertions: ${analysis.testStrategy.specificAssertions?.join(', ') || 'Standard protection assertions'}` 
  : 'Simulate the attack pattern described in the vulnerability description'
}

Generate ONLY the complete test method code. Start with @Test annotation and include proper function signature.`;
    }

    async assessCodebaseRisk(vulnerability, analysis) {
        // Determine critical risk factors
        const criticalFactors = {
            libraryVulnerable: analysis.libraryMitigation?.isLibraryVulnerable || false,
            highSeverityInContext: analysis.impactAssessment?.severityInOurContext === 'CRITICAL' || analysis.impactAssessment?.severityInOurContext === 'HIGH',
            vulnerablePatternsFound: (analysis.codebaseAnalysis?.vulnerablePatterns?.length || 0) > 0,
            highAttackFeasibility: analysis.impactAssessment?.attackVectorFeasibility === 'HIGH',
            lowExploitComplexity: analysis.impactAssessment?.exploitComplexity === 'LOW'
        };

        const criticalRisk = criticalFactors.libraryVulnerable || 
                            (criticalFactors.highSeverityInContext && criticalFactors.vulnerablePatternsFound) ||
                            (criticalFactors.highAttackFeasibility && criticalFactors.lowExploitComplexity);

        return {
            criticalRisk: criticalRisk,
            riskScore: analysis.riskScore || 5.0,
            riskFactors: criticalFactors,
            requiresImmediateAttention: criticalRisk,
            recommendedPriority: criticalRisk ? 'URGENT' : 
                                 analysis.impactAssessment?.severityInOurContext === 'HIGH' ? 'HIGH' : 
                                 analysis.impactAssessment?.severityInOurContext === 'MEDIUM' ? 'MEDIUM' : 'LOW'
        };
    }

    async callAnthropicAPI(prompt) {
        const Anthropic = await this.loadAnthropicSDK();
        const anthropic = new Anthropic({
            apiKey: this.aiConfig.apiKey
        });

        const message = await anthropic.messages.create({
            model: this.aiConfig.model,
            max_tokens: this.aiConfig.maxTokens,
            temperature: this.aiConfig.temperature,
            messages: [{
                role: 'user',
                content: prompt
            }]
        });

        return message.content[0].text;
    }

    async loadAnthropicSDK() {
        try {
            const module = await import('@anthropic-ai/sdk');
            return module.Anthropic;
        } catch (error) {
            throw new Error('Anthropic SDK not installed. Run: npm install @anthropic-ai/sdk');
        }
    }

    parseAIAnalysisResponse(responseText) {
        try {
            // Extract JSON from response (may include explanation text)
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No JSON found in AI response');
            }
            
            const analysis = JSON.parse(jsonMatch[0]);
            
            // Validate required structure
            if (!analysis.impactAssessment || !analysis.riskScore) {
                console.warn('‚ö†Ô∏è  AI response missing required fields, using defaults');
            }
            
            return analysis;
        } catch (error) {
            console.error('‚ùå Failed to parse AI analysis:', error.message);
            return {
                analysisError: error.message,
                impactAssessment: { relevantToOurImplementation: true, severityInOurContext: 'MEDIUM' },
                riskScore: 5.0
            };
        }
    }

    extractTestCode(responseText) {
        // Extract Kotlin test code from AI response
        const codeBlockMatch = responseText.match(/```kotlin\n([\s\S]*?)\n```/);
        if (codeBlockMatch) {
            return codeBlockMatch[1];
        }
        
        // Fallback: look for @Test annotation
        const testMatch = responseText.match(/@Test[\s\S]*?^\s*\}/m);
        if (testMatch) {
            return testMatch[0];
        }
        
        // Final fallback: return the response with formatting
        return responseText.trim();
    }

    // Enhanced version of the original updateVulnerabilityTests method
    async updateVulnerabilityTestsWithAI(newVulnerabilities) {
        if (newVulnerabilities.length === 0) {
            console.log('‚úÖ No new vulnerabilities found');
            return false;
        }

        console.log(`üìù Found ${newVulnerabilities.length} new vulnerabilities, generating AI-enhanced tests...`);
        
        const testFilePath = path.join(__dirname, '../webauthn-server/src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt');
        let testContent = fs.readFileSync(testFilePath, 'utf8');
        
        // Find insertion point (before the final closing brace of the class)
        const insertionPoint = testContent.lastIndexOf('}');
        
        let newTestMethods = '';
        let testSummary = {
            total: newVulnerabilities.length,
            aiGenerated: 0,
            fallback: 0,
            critical: 0
        };
        
        for (const vuln of newVulnerabilities) {
            // Use AI-generated test if available, otherwise fall back to original method
            const testCode = vuln.testImplementation?.testCode || this.generateTestForVulnerability(vuln);
            
            newTestMethods += `\n    ${testCode}\n\n`;
            
            if (vuln.testImplementation?.aiGenerated) {
                testSummary.aiGenerated++;
            } else {
                testSummary.fallback++;
            }
            
            if (vuln.requiresImmediateAction) {
                testSummary.critical++;
            }
        }
        
        // Insert new test methods before the final closing brace
        const updatedContent = testContent.slice(0, insertionPoint) + 
                              newTestMethods + 
                              testContent.slice(insertionPoint);
        
        fs.writeFileSync(testFilePath, updatedContent);
        
        // Update vulnerability tracking with AI enhancements
        this.knownVulnerabilities.vulnerabilities.push(...newVulnerabilities);
        this.knownVulnerabilities.lastCheck = new Date().toISOString();
        this.knownVulnerabilities.aiAnalysis = {
            lastEnhancedAnalysis: new Date().toISOString(),
            testSummary: testSummary
        };
        
        fs.writeFileSync(this.vulnerabilityFile, JSON.stringify(this.knownVulnerabilities, null, 2));
        
        console.log('üìä AI-Enhanced Test Generation Summary:');
        console.log(`   Total vulnerabilities: ${testSummary.total}`);
        console.log(`   AI-generated tests: ${testSummary.aiGenerated}`);
        console.log(`   Fallback tests: ${testSummary.fallback}`);
        console.log(`   Critical vulnerabilities: ${testSummary.critical}`);
        
        return true;
    }

    // Override the main run method to use AI enhancements
    async run() {
        console.log('üîê Starting AI-enhanced vulnerability monitoring...');
        
        try {
            // First run the standard vulnerability monitoring
            const libraryStatus = await this.checkJavaWebAuthnServerDependency();
            const libraryData = await this.fetchJavaWebAuthnServerAdvisories();
            
            const [cveResults, yubicoResults, fidoResults] = await Promise.all([
                this.checkCVEDatabase(libraryData, libraryStatus),
                this.checkYubicoAdvisories(),
                this.checkFIDOAllianceNotices(libraryData, libraryStatus)
            ]);
            
            // Combine and deduplicate results
            const allNewVulns = [...cveResults, ...yubicoResults, ...fidoResults];
            const newVulnerabilities = allNewVulns.filter(vuln => 
                !this.knownVulnerabilities.vulnerabilities.some(known => known.id === vuln.id)
            );
            
            if (newVulnerabilities.length === 0) {
                console.log('‚úÖ No new vulnerabilities found');
                return null;
            }

            // NEW: AI-enhanced vulnerability analysis
            console.log(`ü§ñ Performing AI-enhanced analysis on ${newVulnerabilities.length} vulnerabilities...`);
            const enhancedVulnerabilities = await this.enhancedVulnerabilityAnalysis(newVulnerabilities, libraryData, libraryStatus);
            
            // Filter for actionable vulnerabilities (same as original logic)
            const { actionableVulns, libraryMitigatedVulns } = this.categorizeVulnerabilities(enhancedVulnerabilities, libraryData, libraryStatus);
            
            if (libraryMitigatedVulns.length > 0) {
                console.log(`üìö Found ${libraryMitigatedVulns.length} vulnerabilities already addressed by java-webauthn-server updates`);
            }
            
            // Create tests with AI enhancements
            if (actionableVulns.length > 0) {
                const testsUpdated = await this.updateVulnerabilityTestsWithAI(actionableVulns);
                
                if (testsUpdated) {
                    // Create enhanced PR with AI analysis details
                    const prDetails = await this.createEnhancedPullRequest(actionableVulns);
                    console.log('‚úÖ AI-enhanced vulnerability monitoring complete - PR created for review');
                    return prDetails;
                }
            }
            
            console.log('‚úÖ AI-enhanced vulnerability monitoring complete - no updates needed');
            return null;
            
        } catch (error) {
            console.error('‚ùå Error during AI-enhanced vulnerability monitoring:', error);
            throw error;
        }
    }

    async createEnhancedPullRequest(vulnerabilities) {
        console.log('üöÄ Creating AI-enhanced pull request for vulnerability updates...');
        
        const branchName = `security/ai-vulnerability-updates-${Date.now()}`;
        const criticalCount = vulnerabilities.filter(v => v.requiresImmediateAction).length;
        const aiGeneratedCount = vulnerabilities.filter(v => v.testImplementation?.aiGenerated).length;
        
        const commitMessage = `Add AI-enhanced tests for ${vulnerabilities.length} new WebAuthn vulnerabilities

AI Analysis Summary:
- ${aiGeneratedCount} complete AI-generated test implementations
- ${criticalCount} vulnerabilities requiring immediate attention
- Enhanced with codebase-specific risk assessment

Vulnerabilities addressed:
${vulnerabilities.map(v => `- ${v.id}: ${v.name} (${v.riskAssessment?.recommendedPriority || 'MEDIUM'} priority)`).join('\n')}

ü§ñ Generated with AI-Enhanced Vulnerability Monitor

Co-Authored-By: Claude <noreply@anthropic.com>`;

        try {
            // Create and switch to new branch
            await this.runGitCommand('checkout', ['-b', branchName]);
            console.log(`‚úÖ Created and switched to branch: ${branchName}`);
            
            // Add changed files
            await this.runGitCommand('add', [
                'webauthn-server/src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt',
                'vulnerability-tracking.json'
            ]);
            console.log('‚úÖ Added changed files to staging');
            
            // Commit changes
            await this.runGitCommand('commit', ['-m', commitMessage]);
            console.log('‚úÖ Committed changes');
            
            // Push to remote
            await this.runGitCommand('push', ['-u', 'origin', branchName]);
            console.log(`‚úÖ Pushed branch ${branchName} to remote`);
            
            // Create enhanced pull request
            const prResult = await this.createEnhancedGitHubPullRequest(branchName, commitMessage, vulnerabilities);
            
            return {
                branch: branchName,
                commit: commitMessage,
                filesChanged: ['VulnerabilityProtectionTest.kt', 'vulnerability-tracking.json'],
                pullRequestUrl: prResult.url,
                pullRequestNumber: prResult.number,
                aiEnhanced: true,
                criticalVulnerabilities: criticalCount,
                aiGeneratedTests: aiGeneratedCount
            };
            
        } catch (error) {
            console.error(`‚ùå Failed to create enhanced pull request: ${error.message}`);
            throw error;
        }
    }

    async createEnhancedGitHubPullRequest(branchName, commitMessage, vulnerabilities) {
        const title = `ü§ñ AI-Enhanced Security Tests for ${vulnerabilities.length} new WebAuthn vulnerabilities`;
        const body = this.generateEnhancedPullRequestBody(vulnerabilities, commitMessage);
        
        // Use parent class method for actual PR creation
        return await this.createPullRequestViaAPI(
            await this.getRepoOwner(),
            await this.getRepoName(), 
            branchName, 
            title, 
            body
        );
    }

    generateEnhancedPullRequestBody(vulnerabilities, commitMessage) {
        const criticalVulns = vulnerabilities.filter(v => v.requiresImmediateAction);
        const aiGeneratedTests = vulnerabilities.filter(v => v.testImplementation?.aiGenerated);
        
        const body = `## ü§ñ AI-Enhanced Vulnerability Analysis

This automated pull request adds AI-generated security tests for **${vulnerabilities.length}** newly discovered WebAuthn vulnerabilities.

### üö® Critical Security Alert
${criticalVulns.length > 0 ? 
`**${criticalVulns.length} vulnerabilities require immediate attention:**
${criticalVulns.map(v => `- **${v.id}**: ${v.name} (Risk Score: ${v.riskAssessment?.riskScore || 'Unknown'}/10)`).join('\n')}

‚ö†Ô∏è **These vulnerabilities have been assessed as high-risk for our implementation.**` : 
'‚úÖ No critical vulnerabilities requiring immediate action.'}

### üîç AI Analysis Summary

- **Complete Test Implementations**: ${aiGeneratedTests.length}/${vulnerabilities.length} tests generated with full logic
- **Codebase Risk Assessment**: Each vulnerability analyzed against our specific implementation
- **Library Correlation**: Cross-referenced with java-webauthn-server ${this.securityContext.libraryVersion || 'current'} protections
- **Attack Simulation**: Tests include realistic attack scenarios

### üìä Vulnerability Breakdown

${vulnerabilities.map(v => `#### ${v.id}: ${v.name}
- **Severity**: ${v.severity} (CVSS: ${v.cvssScore})
- **Risk in Our Context**: ${v.aiAnalysis?.impactAssessment?.severityInOurContext || 'Unknown'}
- **Attack Feasibility**: ${v.aiAnalysis?.impactAssessment?.attackVectorFeasibility || 'Unknown'}
- **Library Protection**: ${v.aiAnalysis?.libraryMitigation?.mitigationAvailable ? '‚úÖ Available' : '‚ùå Not Available'}
- **Test Implementation**: ${v.testImplementation?.aiGenerated ? 'ü§ñ AI-Generated Complete Test' : 'üìù Basic Test Stub'}
- **Source**: ${v.source}
- **Priority**: ${v.riskAssessment?.recommendedPriority || 'MEDIUM'}

**Analysis**: ${v.aiAnalysis?.impactAssessment ? 'AI analysis completed' : 'Standard analysis only'}
${v.aiAnalysis?.codebaseAnalysis?.vulnerablePatterns?.length > 0 ? 
  `\n**‚ö†Ô∏è Vulnerable Patterns Found**: ${v.aiAnalysis.codebaseAnalysis.vulnerablePatterns.join(', ')}` : ''}
${v.aiAnalysis?.recommendedActions?.immediate?.length > 0 ? 
  `\n**üö® Immediate Actions**: ${v.aiAnalysis.recommendedActions.immediate.join(', ')}` : ''}
`).join('\n')}

### üß™ Test Implementation Quality

${aiGeneratedTests.length > 0 ? 
`**AI-Generated Tests (${aiGeneratedTests.length})**:
- ‚úÖ Complete implementations with attack simulation
- ‚úÖ Specific assertions based on vulnerability analysis
- ‚úÖ Follows existing test patterns and structure
- ‚úÖ Includes detailed comments explaining the security test

<details>
<summary>View Sample AI-Generated Test</summary>

\`\`\`kotlin
${aiGeneratedTests[0]?.testImplementation?.testCode?.substring(0, 800) || 'Test code not available'}...
\`\`\`
</details>` : ''}

${vulnerabilities.length - aiGeneratedTests.length > 0 ? 
`\n**Standard Test Stubs (${vulnerabilities.length - aiGeneratedTests.length})**:
- üìù Basic test structure requiring manual implementation
- ‚ö†Ô∏è Manual review and completion needed` : ''}

### üõ°Ô∏è Security Review Checklist

**Before merging this PR:**

${criticalVulns.length > 0 ? 
'- [ ] **URGENT: Review critical vulnerabilities immediately**' : '- [x] No critical vulnerabilities found'}
- [ ] Review AI analysis for each vulnerability
- [ ] Verify test implementations match vulnerability descriptions
- [ ] Run security tests: \`./gradlew test --tests="*VulnerabilityProtectionTest*"\`
- [ ] Check if library updates are needed
- [ ] Validate that existing protections are sufficient
${aiGeneratedTests.length > 0 ? '- [ ] Review AI-generated test logic for completeness' : ''}
${vulnerabilities.some(v => v.aiAnalysis?.recommendedActions?.immediate?.length > 0) ? 
'- [ ] **Implement immediate actions identified by AI analysis**' : ''}

### üìö Enhanced Documentation

- **AI Analysis Results**: Full vulnerability impact assessment stored in vulnerability-tracking.json
- **Test Coverage**: ${((this.knownVulnerabilities.testCoverage?.testedVulnerabilities || 0) + vulnerabilities.length)} total vulnerabilities with test coverage
- **Security Agent**: Analysis performed using [WebAuthn Security Analysis Agent](/.claude/agents/webauthn-security-analysis.md)

### üîó Related Resources

- [Vulnerability Tracking Database](/vulnerability-tracking.json)
- [Security Test Suite](/webauthn-server/src/test/kotlin/com/vmenon/mpo/api/authn/security/VulnerabilityProtectionTest.kt)
- [WebAuthn Security Patterns](/.claude/agents/webauthn-security-analysis.md)

---

ü§ñ **This analysis was performed by the AI-Enhanced Vulnerability Monitoring System**  
üìä **Analysis completed**: ${new Date().toISOString()}  
üîê **Security is our top priority - manual review still required**

**Important**: While AI has generated comprehensive test implementations, human security review is essential before merging.`;

        return body;
    }

    async getRepoOwner() {
        const remoteUrl = await this.runGitCommand('config', ['--get', 'remote.origin.url']);
        const match = remoteUrl.match(/github\.com[:/]([^/]+)\//);
        return match ? match[1] : 'unknown';
    }

    async getRepoName() {
        const remoteUrl = await this.runGitCommand('config', ['--get', 'remote.origin.url']);
        const match = remoteUrl.match(/github\.com[:/][^/]+\/([^/.]+)/);
        return match ? match[1] : 'unknown';
    }

    // Additional methods for zero-day vulnerability detection
    async detectZeroDayVulnerabilities() {
        console.log('üîç Scanning for potential zero-day vulnerabilities using pattern analysis...');
        
        if (!this.aiConfig.apiKey) {
            console.warn('‚ö†Ô∏è  Skipping zero-day detection - API key not available');
            return [];
        }

        try {
            const codebasePatterns = await this.analyzeCodebaseSecurityPatterns();
            const potentialVulnerabilities = await this.identifyUnknownSecurityRisks(codebasePatterns);
            
            if (potentialVulnerabilities.length > 0) {
                console.log(`üö® Found ${potentialVulnerabilities.length} potential zero-day security risks`);
                return potentialVulnerabilities;
            }
            
            console.log('‚úÖ No potential zero-day vulnerabilities detected');
            return [];
            
        } catch (error) {
            console.error('‚ùå Zero-day detection failed:', error.message);
            return [];
        }
    }

    async analyzeCodebaseSecurityPatterns() {
        // Analyze codebase for security anti-patterns that might indicate vulnerabilities
        const prompt = `Analyze this WebAuthn codebase for potential security anti-patterns that could lead to undisclosed vulnerabilities:

${Object.entries(this.securityContext.codebase).map(([file, content]) => 
  `--- ${file} ---\n${content}`
).join('\n\n')}

Look for patterns such as:
- Information disclosure in error handling
- Timing vulnerabilities in authentication
- Insufficient input validation
- Weak random number generation
- Race conditions in session management
- Cross-origin policy weaknesses

Return a JSON array of potential security concerns with severity assessment.`;

        const response = await this.callAnthropicAPI(prompt);
        return this.parseSecurityPatternsResponse(response);
    }
}

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
    const monitor = new AIEnhancedVulnerabilityMonitor();
    monitor.run()
        .then((result) => {
            if (result) {
                console.log('ü§ñ AI-Enhanced Vulnerability Monitoring Results:', result);
            }
            process.exit(0);
        })
        .catch((error) => {
            console.error('‚ùå AI-Enhanced monitoring failed:', error);
            process.exit(1);
        });
}

export default AIEnhancedVulnerabilityMonitor;