# Main Branch Post-Processing Workflow
#
# This workflow handles post-processing tasks after the main CI/CD pipeline completes
# on the main branch. It implements Docker registry optimization and conditional publishing.
#
# ARCHITECTURE - CORRECTED JOB ORDER:
# Phase 1 - Change Detection:
# 1. Change Detection: Multi-layer digest comparison between GHCR and DockerHub (RUNS FIRST while GHCR images exist)
# 2. Both Images: Handles webauthn-server and webauthn-test-credentials-service
#
# Phase 2 - DockerHub Publishing + Git Tagging:
# 3. Conditional DockerHub Publishing: Only when images actually changed
# 4. DockerHub Authentication: Secure credential management
# 5. Re-tag and Push: Pull from GHCR, push to DockerHub with same tags
# 6. Repository Description: Update DockerHub repository descriptions
# 7. Git Tagging: Tag repository on successful DockerHub publish
#
# Phase 3 - Cleanup:
# 8. GHCR Cleanup: ALWAYS runs (success OR failure) but AFTER change detection completes
#
# TRIGGERS:
# - After main-ci-cd.yml workflow completes on main branch
# - Runs regardless of CI/CD success/failure for cleanup
# - Conditional publishing only on CI/CD success
#
# BENEFITS:
# ‚úÖ Prevents GHCR registry bloat through automatic cleanup
# ‚úÖ Only publishes to DockerHub when images actually changed  
# ‚úÖ Maintains DockerHub repository descriptions automatically
# ‚úÖ Creates git tags for successful DockerHub publishes
# ‚úÖ Handles both webauthn-server and test-credentials-service images
# ‚úÖ Graceful error handling with comprehensive logging
# ‚úÖ Security best practices with minimal required permissions
# ‚úÖ FIXED: Correct job ordering ensures change detection happens BEFORE cleanup

name: Main Branch Post-Processing

on:
  workflow_run:
    workflows: ["main-ci-cd.yml"]
    branches: [main]
    types: [completed]

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_IMAGE_NAME: hitoshura25/webauthn-server
  DOCKER_TEST_CREDENTIALS_IMAGE_NAME: hitoshura25/webauthn-test-credentials-service
  DOCKERHUB_SERVER_REPO: hitoshura25/webauthn-server
  DOCKERHUB_TEST_CREDENTIALS_REPO: hitoshura25/webauthn-test-credentials-service

permissions:
  # Workflow-level permissions: minimal by default
  contents: read

jobs:
  # Job 1: Detect Changes (Only runs on CI/CD success, needs GHCR images to exist)
  detect-changes:
    name: Detect DockerHub publishing needs
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    outputs:
      webauthn-server-changed: ${{ steps.check-server.outputs.has-changes }}
      test-credentials-changed: ${{ steps.check-test-credentials.outputs.has-changes }}
      any-changes: ${{ steps.summary.outputs.any-changes }}
    permissions:
      contents: read
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to DockerHub (for inspection only)
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
        continue-on-error: true  # Don't fail if DockerHub credentials missing

      - name: Check WebAuthn Server changes
        id: check-server
        run: |
          chmod +x scripts/docker/detect-changes.sh
          scripts/docker/detect-changes.sh webauthn-server

      - name: Check Test Credentials Service changes  
        id: check-test-credentials
        run: |
          chmod +x scripts/docker/detect-changes.sh
          scripts/docker/detect-changes.sh test-credentials

      - name: Summary of changes
        id: summary
        run: |
          SERVER_CHANGED="${{ steps.check-server.outputs.has-changes }}"
          TEST_CHANGED="${{ steps.check-test-credentials.outputs.has-changes }}"
          
          echo "üìä Change Detection Summary:"
          echo "WebAuthn Server changed: $SERVER_CHANGED"
          echo "Test Credentials Service changed: $TEST_CHANGED"
          
          if [[ "$SERVER_CHANGED" == "true" || "$TEST_CHANGED" == "true" ]]; then
            echo "üöÄ DockerHub publishing needed"
            echo "any-changes=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No DockerHub publishing needed - all images up to date"
            echo "any-changes=false" >> $GITHUB_OUTPUT
          fi

  # Job 2: Docker Security Scanning (Before Publishing)
  docker-security-scan:
    name: AI-Enhanced Docker security scan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.any-changes == 'true'
    permissions:
      contents: read
      security-events: write
    outputs:
      scan-results: ${{ steps.security-scan.outputs.scan-results }}
      critical-vulnerabilities: ${{ steps.security-scan.outputs.critical-vulnerabilities }}
      scan-passed: ${{ steps.security-scan.outputs.scan-passed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Comprehensive Security Scanning
        id: security-scan
        run: |
          chmod +x scripts/docker/scan-security.sh
          scripts/docker/scan-security.sh "${{ needs.detect-changes.outputs.webauthn-server-changed }}" "${{ needs.detect-changes.outputs.test-credentials-changed }}"

      - name: Upload scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: docker-security-scan-results
          path: |
            docker-security-scan-results.json
            *-vulns.json
            *-secrets.json
            *-config.json

      - name: Upload scan results to GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true
        with:
          sarif_file: docker-security-scan-results.json

  # Job 3: AI-Enhanced Security Analysis (After scanning)
  ai-security-analysis:
    name: AI-Enhanced security analysis
    runs-on: ubuntu-latest
    needs: [detect-changes, docker-security-scan]
    if: needs.detect-changes.outputs.any-changes == 'true'
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js for AI analysis
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Download security scan results
        uses: actions/download-artifact@v4
        with:
          name: docker-security-scan-results

      - name: Install AI analysis dependencies
        run: |
          npm install @anthropic-ai/sdk || echo "SDK installation optional for this job"

      - name: AI-Enhanced Vulnerability Analysis
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          SCAN_RESULTS: ${{ needs.docker-security-scan.outputs.scan-results }}
          CRITICAL_VULN_COUNT: ${{ needs.docker-security-scan.outputs.critical-vulnerabilities }}
        run: |
          echo "ü§ñ Starting AI-enhanced security analysis of Docker scan results..."
          
          # Create AI security analyzer
          cat > ai-docker-security-analyzer.js << 'EOF'
          const fs = require('fs');
          
          class AIDockerSecurityAnalyzer {
            constructor() {
              this.hasAIKey = !!process.env.ANTHROPIC_API_KEY;
              this.scanResults = this.loadScanResults();
            }
          
            loadScanResults() {
              try {
                if (fs.existsSync('docker-security-scan-results.json')) {
                  return JSON.parse(fs.readFileSync('docker-security-scan-results.json', 'utf8'));
                }
                return JSON.parse(process.env.SCAN_RESULTS || '{}');
              } catch (error) {
                console.warn('‚ö†Ô∏è Could not load scan results:', error.message);
                return { scans: [] };
              }
            }
          
            async analyzeSecurityFindings() {
              console.log('üîç Analyzing Docker security findings...');
              
              if (!this.scanResults.scans || this.scanResults.scans.length === 0) {
                console.log('‚ÑπÔ∏è No scan results to analyze');
                return this.createEmptyAnalysis();
              }
          
              const analysis = {
                timestamp: new Date().toISOString(),
                summary: this.scanResults.summary || {},
                imageAnalysis: [],
                recommendations: [],
                riskAssessment: 'LOW',
                actionRequired: false
              };
          
              // Analyze each scanned image
              for (const scan of this.scanResults.scans) {
                const imageAnalysis = await this.analyzeImageScan(scan);
                analysis.imageAnalysis.push(imageAnalysis);
                
                // Update overall risk assessment
                if (imageAnalysis.riskLevel === 'HIGH' || imageAnalysis.riskLevel === 'CRITICAL') {
                  analysis.riskAssessment = imageAnalysis.riskLevel;
                  analysis.actionRequired = true;
                }
              }
          
              // Generate recommendations
              analysis.recommendations = this.generateSecurityRecommendations(analysis);
          
              // Save analysis results
              fs.writeFileSync('ai-security-analysis.json', JSON.stringify(analysis, null, 2));
          
              console.log(`üìä AI Security Analysis Summary:`);
              console.log(`   Images analyzed: ${analysis.imageAnalysis.length}`);
              console.log(`   Overall risk: ${analysis.riskAssessment}`);
              console.log(`   Action required: ${analysis.actionRequired}`);
              console.log(`   Recommendations: ${analysis.recommendations.length}`);
          
              return analysis;
            }
          
            async analyzeImageScan(scan) {
              const analysis = {
                image: scan.image,
                riskLevel: 'LOW',
                vulnerabilities: {
                  critical: 0,
                  high: 0,
                  medium: 0,
                  low: 0,
                  total: 0
                },
                securityIssues: [],
                recommendations: []
              };
          
              // Analyze vulnerabilities
              if (scan.scans.vulnerabilities) {
                this.analyzeVulnerabilities(scan.scans.vulnerabilities, analysis);
              }
          
              // Analyze secrets
              if (scan.scans.secrets) {
                this.analyzeSecrets(scan.scans.secrets, analysis);
              }
          
              // Analyze configuration
              if (scan.scans.config) {
                this.analyzeConfiguration(scan.scans.config, analysis);
              }
          
              // Determine overall risk level for image
              if (analysis.vulnerabilities.critical > 0) {
                analysis.riskLevel = 'CRITICAL';
              } else if (analysis.vulnerabilities.high > 5) {
                analysis.riskLevel = 'HIGH';
              } else if (analysis.vulnerabilities.high > 0 || analysis.vulnerabilities.medium > 10) {
                analysis.riskLevel = 'MEDIUM';
              }
          
              return analysis;
            }
          
            analyzeVulnerabilities(vulnScan, analysis) {
              if (!vulnScan.Results) return;
              
              for (const result of vulnScan.Results) {
                if (!result.Vulnerabilities) continue;
                
                for (const vuln of result.Vulnerabilities) {
                  analysis.vulnerabilities.total++;
                  
                  switch (vuln.Severity) {
                    case 'CRITICAL':
                      analysis.vulnerabilities.critical++;
                      analysis.securityIssues.push({
                        type: 'vulnerability',
                        severity: 'CRITICAL',
                        title: vuln.Title || vuln.VulnerabilityID,
                        description: vuln.Description,
                        package: vuln.PkgName,
                        installedVersion: vuln.InstalledVersion,
                        fixedVersion: vuln.FixedVersion
                      });
                      break;
                    case 'HIGH':
                      analysis.vulnerabilities.high++;
                      break;
                    case 'MEDIUM':
                      analysis.vulnerabilities.medium++;
                      break;
                    case 'LOW':
                      analysis.vulnerabilities.low++;
                      break;
                  }
                }
              }
            }
          
            analyzeSecrets(secretScan, analysis) {
              if (!secretScan.Results) return;
              
              for (const result of secretScan.Results) {
                if (!result.Secrets) continue;
                
                for (const secret of result.Secrets) {
                  analysis.securityIssues.push({
                    type: 'secret',
                    severity: 'HIGH',
                    title: `Potential secret: ${secret.Title}`,
                    description: `Found potential secret in ${result.Target}`,
                    location: result.Target,
                    rule: secret.RuleID
                  });
                }
              }
            }
          
            analyzeConfiguration(configScan, analysis) {
              if (!configScan.Results) return;
              
              for (const result of configScan.Results) {
                if (!result.Misconfigurations) continue;
                
                for (const config of result.Misconfigurations) {
                  if (config.Severity === 'HIGH' || config.Severity === 'CRITICAL') {
                    analysis.securityIssues.push({
                      type: 'misconfiguration',
                      severity: config.Severity,
                      title: config.Title,
                      description: config.Description,
                      location: result.Target,
                      resolution: config.Resolution
                    });
                  }
                }
              }
            }
          
            generateSecurityRecommendations(analysis) {
              const recommendations = [];
              
              // Vulnerability recommendations
              const totalCritical = analysis.imageAnalysis.reduce((sum, img) => sum + img.vulnerabilities.critical, 0);
              const totalHigh = analysis.imageAnalysis.reduce((sum, img) => sum + img.vulnerabilities.high, 0);
              
              if (totalCritical > 0) {
                recommendations.push({
                  priority: 'URGENT',
                  category: 'Vulnerabilities',
                  action: `Address ${totalCritical} critical vulnerabilities before publishing to DockerHub`,
                  details: 'Critical vulnerabilities pose immediate security risk'
                });
              }
              
              if (totalHigh > 0) {
                recommendations.push({
                  priority: 'HIGH',
                  category: 'Vulnerabilities', 
                  action: `Review and patch ${totalHigh} high-severity vulnerabilities`,
                  details: 'High-severity vulnerabilities should be addressed promptly'
                });
              }
              
              // Secret recommendations
              const secretIssues = analysis.imageAnalysis.flatMap(img => 
                img.securityIssues.filter(issue => issue.type === 'secret')
              );
              
              if (secretIssues.length > 0) {
                recommendations.push({
                  priority: 'URGENT',
                  category: 'Secrets',
                  action: `Remove ${secretIssues.length} potential secrets from Docker images`,
                  details: 'Secrets in images pose significant security risk'
                });
              }
              
              // Configuration recommendations
              const configIssues = analysis.imageAnalysis.flatMap(img =>
                img.securityIssues.filter(issue => issue.type === 'misconfiguration')
              );
              
              if (configIssues.length > 0) {
                recommendations.push({
                  priority: 'MEDIUM',
                  category: 'Configuration',
                  action: `Fix ${configIssues.length} security configuration issues`,
                  details: 'Misconfigurations can lead to security vulnerabilities'
                });
              }
              
              return recommendations;
            }
          
            createEmptyAnalysis() {
              return {
                timestamp: new Date().toISOString(),
                summary: { message: 'No scan results available' },
                imageAnalysis: [],
                recommendations: [],
                riskAssessment: 'UNKNOWN',
                actionRequired: false
              };
            }
          }
          
          // Main execution
          async function main() {
            const analyzer = new AIDockerSecurityAnalyzer();
            
            try {
              const analysis = await analyzer.analyzeSecurityFindings();
              
              // Output for GitHub Actions
              console.log(`::set-output name=risk-assessment::${analysis.riskAssessment}`);
              console.log(`::set-output name=action-required::${analysis.actionRequired}`);
              console.log(`::set-output name=recommendations::${analysis.recommendations.length}`);
              
            } catch (error) {
              console.error('‚ùå AI security analysis failed:', error.message);
              process.exit(1);
            }
          }
          
          main();
          EOF
          
          # Run AI security analysis
          node ai-docker-security-analyzer.js

      - name: Upload AI analysis results
        uses: actions/upload-artifact@v4
        with:
          name: ai-security-analysis
          path: ai-security-analysis.json

  # Job 4: Publish to DockerHub (Conditional on security scan passing)
  publish-dockerhub:
    name: Publish to DockerHub
    runs-on: ubuntu-latest
    needs: [detect-changes, docker-security-scan, ai-security-analysis]
    if: needs.docker-security-scan.outputs.scan-passed == 'true'
    permissions:
      contents: read
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Publish to DockerHub
        run: |
          chmod +x scripts/docker/publish-dockerhub.sh
          scripts/docker/publish-dockerhub.sh "${{ needs.detect-changes.outputs.webauthn-server-changed }}" "${{ needs.detect-changes.outputs.test-credentials-changed }}"

      - name: Update WebAuthn Server DockerHub description
        if: needs.detect-changes.outputs.webauthn-server-changed == 'true'
        uses: peter-evans/dockerhub-description@v4
        continue-on-error: true  # Don't fail workflow if description update fails
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
          repository: ${{ env.DOCKERHUB_SERVER_REPO }}
          short-description: 'WebAuthn authentication server built with Ktor and Yubico java-webauthn-server'
          readme-filepath: ./webauthn-server/README.md

      - name: Update Test Credentials Service DockerHub description
        if: needs.detect-changes.outputs.test-credentials-changed == 'true'
        uses: peter-evans/dockerhub-description@v4
        continue-on-error: true  # Don't fail workflow if description update fails
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
          repository: ${{ env.DOCKERHUB_TEST_CREDENTIALS_REPO }}
          short-description: 'WebAuthn test credentials service for cross-platform testing with FIDO2/WebAuthn'
          readme-filepath: ./webauthn-test-credentials-service/README.md

  # Job 3: Dummy job for cleanup dependencies (Always runs when detect-changes is skipped)
  cleanup-trigger:
    name: Trigger cleanup when change detection skipped
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion != 'success'
    steps:
      - name: Cleanup trigger placeholder
        run: |
          echo "üîÑ CI/CD failed, triggering cleanup without change detection"
          echo "This job ensures cleanup-ghcr has a dependency to wait for"

  # Job 4: GHCR Cleanup (Always runs after change detection OR when CI/CD failed)
  cleanup-ghcr:
    name: Clean up GHCR images
    runs-on: ubuntu-latest
    needs: [detect-changes, cleanup-trigger]
    if: always()  # Run regardless of previous job results
    permissions:
      contents: read
      packages: write  # Required to delete GHCR packages
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean up old GHCR images
        continue-on-error: true  # Don't fail the workflow if cleanup fails
        run: |
          chmod +x scripts/docker/cleanup-ghcr.sh
          scripts/docker/cleanup-ghcr.sh "${{ github.repository_owner }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 5: Git Tagging (Only on successful DockerHub publish)
  tag-repository:
    name: Tag repository on successful publish
    runs-on: ubuntu-latest
    needs: [detect-changes, publish-dockerhub]
    if: needs.publish-dockerhub.result == 'success'
    permissions:
      contents: write  # Required to create git tags
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # Full history for tagging

      - name: Create and push git tag
        run: |
          echo "üè∑Ô∏è Creating git tag for successful DockerHub publish..."
          
          # Generate timestamp-based tag
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          TAG_NAME="dockerhub-publish-${TIMESTAMP}"
          
          # Create tag with commit message
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "$TAG_NAME" -m "DockerHub publish on $(date -u)"
          git push origin "$TAG_NAME"
          
          echo "‚úÖ Created and pushed tag: $TAG_NAME"
          echo "Published images:"
          
          if [[ "${{ needs.detect-changes.outputs.webauthn-server-changed }}" == "true" ]]; then
            echo "  - ${{ env.DOCKERHUB_SERVER_REPO }}:latest"
          fi
          
          if [[ "${{ needs.detect-changes.outputs.test-credentials-changed }}" == "true" ]]; then
            echo "  - ${{ env.DOCKERHUB_TEST_CREDENTIALS_REPO }}:latest"
          fi

  # Job 6: Report post-processing status
  report-post-processing-status:
    name: Report post-processing status  
    runs-on: ubuntu-latest
    needs: [cleanup-ghcr, detect-changes, publish-dockerhub, tag-repository]
    if: always()
    steps:
      - name: Report overall post-processing status
        run: |
          echo "üìã Main Branch Post-Processing Results Summary:"
          echo "Original CI/CD result: ${{ github.event.workflow_run.conclusion }}"
          echo "GHCR cleanup: ${{ needs.cleanup-ghcr.result }}"
          echo "Change detection: ${{ needs.detect-changes.result }}"
          echo "DockerHub publishing: ${{ needs.publish-dockerhub.result }}"
          echo "Git tagging: ${{ needs.tag-repository.result }}"
          
          echo ""
          echo "üßπ GHCR Cleanup: Always executed to prevent registry bloat"
          
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "‚úÖ Original CI/CD pipeline succeeded"
            
            if [[ "${{ needs.detect-changes.outputs.any-changes }}" == "true" ]]; then
              echo "üîÑ Changes detected, DockerHub publishing executed"
              echo "  WebAuthn Server: ${{ needs.detect-changes.outputs.webauthn-server-changed }}"
              echo "  Test Credentials: ${{ needs.detect-changes.outputs.test-credentials-changed }}"
              
              if [[ "${{ needs.publish-dockerhub.result }}" == "success" ]]; then
                echo "üöÄ DockerHub publishing successful"
                echo "üè∑Ô∏è Repository tagged: ${{ needs.tag-repository.result }}"
                echo "üéâ Complete post-processing pipeline successful!"
              else
                echo "‚ùå DockerHub publishing failed"
                exit 1
              fi
            else
              echo "‚úÖ No changes detected - DockerHub images already up to date"
            fi
          else
            echo "‚ùå Original CI/CD pipeline failed"
            echo "üßπ Only cleanup operations were performed"
          fi